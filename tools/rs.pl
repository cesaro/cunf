#!/usr/bin/perl -w

use strict;
use vars qw (@places %label %in %out %indeg @cut0 %cutofft %cutoffh);
use vars qw (%reach %markings);

sub debug {
	#print STDERR @_, "\n";
}

sub build_cut0 {
	my %init = %{$_[0]};

	# if autodetect has been requested, append to %m0 all places with no
	# incoming arcs
	if ($init{"autodetect"}) {
		delete $init{"autodetect"};
		for (@places) {
			$init{$_} = 1 unless $indeg{$_};
		}
	}

	# get the keys of init hash
	@cut0 = keys %init;

	debug "Using initial marking: '@cut0'"; 
}

sub read_net {
	my ($file) = @_;
	my %hplaces;
	my %init;
	my $h;
	my @hl;
	my $hid;
	my $p;
	my $t;
	my $lbl;
	my $pnr;
	my $enr;

	open FD, '<', $file or die "'$file': $!";
	while (<FD>) {

		# match the autodetect comment generated by net2dot tool
		$init{"autodetect"} = 1 if /\* autodetect initial marking \*/;

		# parse cutoff histories in contextual unfoldings
		if (/^\s+\*(h\d+)\s+\d+\s+\d+\s+(.*) <br align/) {
			$h = $2;
			$hid = $1;
			$h =~ s/(, ){0,1}e0:_t0_//;
			@hl = split (", ", $h);
			$cutoffh{$hid} = \@hl;
			debug "file $file cutoff history $hid contents '@hl'";
		}

		# while parsing events, conditions and cutoffs, skip e0
		next if /\be0\b/;

		# place -> transition
		if (/^\s*([cp]\d*)\s*->\s*([et]\d*)/) {
			($p, $t) = ($1, $2);
			debug "file $file edge p>t $p > $t";
			$hplaces{$p} = 1;
			$indeg{$t}++;
			push @{$out{$p}}, ($t);
			push (@{$in{$t}}, ($p)) unless /arrowhead=none/;
		}

		# transition -> place
		if (/^\s*([et]\d*)\s*->\s*([cp]\d*);/) {
			($t, $p) = ($1, $2);
			debug "file $file edge t>p $t > $p";
			$hplaces{$p} = 1;
			$indeg{$p}++;
			push @{$out{$t}}, ($p);
			push @{$in{$p}}, ($t);
		}

		# label of a place
		if (/^\s*([cp]\d*)\s*.label="([^ :"]*)/) {
			($p, $lbl) = ($1, $2);
			debug "file $file p $p label $lbl";
			$hplaces{$p} = 1;
			$label{$p} = $lbl;
			$init{$p} = 1 if (/\* initial \*/);
		}

		# label of a transition
		if (/^\s*([et]\d*)\s*.label="([^ :"]*)/) {
			debug "file $file t $1 label $2";
			$label{$1} = $2;
		}

		# transition (event) is a cutoff
		if (/^\s*(e\d*)\s.*shape=Msquare/) {
			$cutofft{$1} = 1;
			debug "file $file t $1 is a cutoff";
		}
	}
	close FD;

	# build the list of places in the net
	@places = keys %hplaces;

	# and print the number of places, transitions read
	$pnr = @places;
	$enr = (keys %label) - $pnr;
	print "Net at '$file';  $enr transitions/events, $pnr " .
			"places/conditions";
	print " (autodetecting initial marking)" if $init{"autodetect"};
	print "\n";

	die "Error: No transitions read, sure about file format?" unless $enr;

	# build the initial marking
	build_cut0 \%init;
}

sub cut2labeling {
	my @cut = @_;

	# returns the marking string associated to a list of conditions
	# (places)

	return join (" ", sort (map {$label{$_}} @cut));
}

sub cut2key {
	my @cut = @_;

	return join ("_", sort @cut);
}

sub trans2labeling {
	my @trans = @_;
	return join (" ", (map {"$_:$label{$_}"} @trans));
}

sub enabled {
	my @cut = @_;
	my @fire;
	my $p;
	my $t;
	my %i;
	
	# get a copy of the in-degre hash table
	%i = %indeg;

	# for each place, decrement the transitions in its postset
	for $p (@cut) {
		next unless defined($out{$p});
		for $t (@{$out{$p}}) {
			$i{$t}--;
			push @fire, ($t) if $i{$t} == 0;
		}
	}
	return @fire;
}

sub fire {
	my @cut = @{$_[0]};
	my $t = $_[1];

	my %h;
	my $p;

	# build a hash table using the cut
	$h{$_} = 1 for @cut;

	# unmark preset
	for $p (@{$in{$t}}) {
		delete $h{$p};
	}

	# mark postset
	for $p (@{$out{$t}}) {
		if (defined $h{$p}) {
			print "Network is not safe!!\n";
			exit 1;
		}
		$h{$p} = 1;
	}

	# keys of the hash h conforms the new marking
	return keys %h;
}

sub reach {
	my @work;
	my $m;
	my $nm;
	my @cut;
	my @ncut;
	my @ena;
	my $t;

	# populate the work set and the reach hash table with the initial cut
	push @work, \@cut0;
	$m = cut2key @cut0;
	$reach{$m} = [];
	debug "Cut0: @cut0 -> $m";

	# while we have a cut to explore
	while ($#work >= 0) {

		# get a cut, build its marking and get its configuration (list
		# of transitions/events)
		@cut = @{shift @work};
		$m = cut2key @cut;
		debug "Processing cut @cut, key $m (still ", $#work + 1, ")";

		# get a list of transitions enabled at this cut
		@ena = enabled @cut;
		debug " enabled: @ena";

		# fire each transition and use the new cut if not already seen
		for $t (@ena) {
			@ncut = fire (\@cut, $t);
			$nm = cut2key @ncut;
			debug " fired $t, gives cut @ncut, key $nm";
			if (! defined ($reach{$nm})) {
				$reach{$nm} = [@{$reach{$m}}, $t];
				push @work, [@ncut];
			} else {
				debug "  droping, already reached ",
					"by @{$reach{$nm}}";
			}
		}
	}
}

sub reach2markings {
	my $k;
	my $l;
	my @cut;

	for $k (keys %reach) {
		@cut = split ("_", $k);
		$l = cut2labeling @cut;
		if (defined ($markings{$l})) {
			$markings{$l} = ["*", @{$reach{$k}}];
		} else {
			$markings{$l} = $reach{$k};
		}
	}
}

sub print_markings {
	my $k;
	my $i;

	# we may have added transition "*" to the list of transitions
	$label{"*"} = "*";

	$i = 0;
	for $k (sort (keys %markings)) {
		#print "$k  after ", trans2labeling (@{$markings{$k}}), "\n";
		print "$k\n";
		$i++;
	}
	print " -- $i markings\n"
}

sub test {
	my $e;
	my %h;

	for $e ("c1", "c2", "c3", "c4", "c2", "c1", "c3", "c1") {
		print "$e\n";
		push @{$h{$e}}, ($e);
	}

	for (keys %h) {
		print "k '$_' v '@{$h{$_}}'\n";
	}
}

sub main {
	if (@ARGV != 1) {
		print "Usage: rs.pl DOTFILE\n";
		exit 1;
	}
	read_net $ARGV[0];
	reach ();
	reach2markings ();
	print_markings ();
}

main ();


#!/usr/bin/env python

import sys
import math
import networkx
#import cProfile
#import psyco

class Event (object) :
    def __init__ (self, nr, l="", pre=[], post=[], cont=[], iscutoff=False) :
        self.nr = nr
        self.label = l
        self.pre = pre
        self.post = post
        self.cont = cont
        self.iscutoff = iscutoff
        self.mark = 0

        for c in pre : c.post.append (self)
        for c in post : c.pre = self
        for c in cont : c.cont.append (self)

    def __repr__ (self) :
        return 'e%d' % self.nr

    def __str__ (self) :
        if (self.iscutoff) : s = '*'
        else : s = ''
        return "%se%d:%s Pre %s;  Cont %s;  Post %s" \
                % (s, self.nr, self.label, self.pre, self.cont, self.post)

class Condition (object) :
    def __init__ (self, nr, l="", pre=None, post=[], cont=[]) :
        self.nr = nr
        self.label = l
        self.pre = pre
        self.post = post
        self.cont = cont

        if (pre) : pre.post.append (self)
        for e in post : e.pre.append (self)
        for e in cont : e.cont.append (self)

    def __repr__ (self) :
        return 'c%d' % self.nr

    def __str__ (self) :
        return 'c%d:%s Pre %s;  Cont %s;  Post %s' \
                % (self.nr, self.label, repr (self.pre), self.cont, self.post)

class Unfolding (object) :

    def __init__ (self) :
        self.conds = [None]
        self.events = [None]
        self.m0 = []

    def __is_event_id (self, i) :
        return 0 <= i < len (self.events)

    def __is_cond_id (self, i) :
        return 1 <= i < len (self.conds)

    def __sane_event_id (self, i) :
        if (self.__is_event_id (i)) : return
        raise Exception, '%s: invalid event nr' % i
        
    def __sane_cond_id (self, i) :
        if (self.__is_cond_id (i)) : return
        raise Exception, '%s: invalid condition nr' % i

    def add_cond (self, l, pre=0, post=[], cont=[]) :
        # validate event identifiers
        self.__sane_event_id (pre)
        for i in post : self.__sane_event_id (i)
        for i in cont : self.__sane_event_id (i)

        # map to object references
        po = [self.events[i] for i in post]
        co = [self.events[i] for i in cont]

        # create the new condition and register it
        c = Condition (len (self.conds), l, self.events[pre], po, co)
        self.conds.append (c)
        if (pre == None) : self.m0.append (c)
        return c

    def add_event (self, l, pre=[], post=[], cont=[], iscutoff=False) :
        # validate condition identifiers
        for i in pre : self.__sane_cond_id (i)
        for i in post : self.__sane_cond_id (i)
        for i in cont : self.__sane_cond_id (i)

        # map to object references
        pr = [self.conds[i] for i in pre]
        po = [self.conds[i] for i in post]
        co = [self.conds[i] for i in cont]

        # create the new event and register it
        e = Event (len (self.events), l, pr, po, co, iscutoff)
        self.events.append (e)
        return e

    def unf2dot (self, f) :
        f.write ('digraph {\n')
        f.write ('\t/* events */\n')
        f.write ('\tnode\t[shape=box style=filled fillcolor=grey80];\n')
        for e in self.events :
            if (e == None) : continue
            s = '\te%-6d [label="%s:e%d"' % \
                    (e.nr, e.label, e.nr)
            if (e.iscutoff) : s += ' shape=Msquare'
            if (e.mark) : s += ' fillcolor=blue'
            f.write (s + '];\n')

        f.write ('\n\t/* conditions, flow and context relations */\n')
        f.write ('\tnode\t[shape=circle fillcolor=gray95];')
        for c in self.conds :
            if (c == None) : continue
            s = '\n\tc%-6d [label="%s:c%d"];' % (c.nr, c.label, c.nr)
            if (c.pre == None) : s += ' /* initial */\n'
            else : s += '\n\te%-6d -> c%d;\n' % (c.pre.nr, c.nr)

            for e in c.post :
                s += '\tc%-6d -> e%d;\n' % (c.nr, e.nr)
            for e in c.cont :
                s += '\tc%-6d -> e%d [arrowhead=none color=red];\n' \
                        % (c.nr, e.nr)
            f.write (s)
        f.write ('}\n') 

    def __cuf2unf_readstr (self, f, m) :
        s = ""
        for i in xrange (0, m) :
            t = f.read (1)
            if (t == '\x00') : return s
            s += t
        raise Exception, 'File corruption detected'

    def __cuf2unf_readint (self, f) :
        s = f.read (4)
        if (len (s) != 4) : raise Exception, 'File corruption detected'
        r = (ord (s[0]) << 24) + (ord (s[1]) << 16)
        r += (ord (s[2]) << 8) + ord (s[3])
        return r

    def cuf2unf (self, f) :
        # read first four fields
        nrc = self.__cuf2unf_readint (f)
        nre = self.__cuf2unf_readint (f)
        nrf = self.__cuf2unf_readint (f)
        m = 1 + self.__cuf2unf_readint (f)
        #r, nrc, nre, nrf, m

        # read nre event (nrf cutoff event) labels
        for i in xrange (0, nre - nrf) :
            self.add_event (self.__cuf2unf_readstr (f, m))
        for i in xrange (nre - nrf, nre) :
            l = self.__cuf2unf_readstr (f, m)
            self.add_event (l, iscutoff=True)

        # read condition labels, flow and context relations
        for i in xrange (0, nrc) :
            l = self.__cuf2unf_readstr (f, m)
            pre = self.__cuf2unf_readint (f)
            post = []
            cont = []
            while True :
                e = self.__cuf2unf_readint (f)
                if (not e) : break
                post.append (e)
            while True :
                e = self.__cuf2unf_readint (f)
                if (not e) : break
                cont.append (e)
#            debug (l, pre, post, cont)
            self.add_cond (l, pre, post, cont)

    def __conflicts_systematic (self, f) :
        # generate asymmetric conflict graph (with sym. conflicts)
        g = self.__conflicts_asym_graph (True)

        # search for all elementary circuits in g and filter out those that
        # are contained in another one
        cycles = networkx.algorithms.simple_cycles (g)
#        for x in cycles: debug ('cycle', x)
        debug ('systematic:', len (cycles), 'found; filtering out')
        tmp, rem = set (), set ()
        for x in cycles :
            assert (x)
            y = frozenset (x)
            rem.clear ()
            for z in tmp :
                if z <= y :
#                    debug ('discarding', z)
                    y = None;
                    break
                if z > y : rem.add (z)
            for z in rem : tmp.remove (z)
#            for z in rem : debug ('removing', z)
            if y : tmp.add (y)
#            if y : debug ('taking', y)
        cycles = tmp
        debug ('done,', len (cycles), 'cycles taken')

        # enumeration of asymmetric cycles
        s, j = '', 0
        for x in cycles :
            s += 'z%d := ~ AND (' % j
            s += ', '.join ('e%d' % y for y in x)
            s += ');\n'
            j += 1
        if j :
            s += 'ASSIGN t'
            for i in xrange (j) : s += ',z%d' % i
            s += ';\n'
        f.write (s)

    def __conflicts_atom (self, f) :
        # encode symmetric conflicts
        debug ('atom encoding, encoding symmetric conflicts')
        i, s, l, tmp = 0, '', [], set ()
        for c in self.conds :
            if c == None : continue
            a = frozenset ([e for e in c.post if not e.iscutoff])
            if len (a) < 2 : continue
            tmp.clear ()
            for b in l :
                if a <= b : debug ('discarding', a); a = None; break
                if b < a : tmp.add (b)
            for b in tmp : l.remove (b)
            for b in tmp : debug ('removing', b)
            if a : l.append (a)
            if a : debug ('taking', a)
        for a in l :
            s += 'y%d := [0, 1] (' % i
            s += ', '.join ('e%d' % e.nr for e in a) + ');\n'
            i += 1
        if i :
            f.write (s + 'ASSIGN ')
            s = ''
            for a in xrange (i) : s += ', y%d' % a
            s = s[2:] + ';\n\n'
        f.write (s)

        # generate asymmetric conflict graph (without sym. conflicts)
        g = self.__conflicts_asym_graph (False)

        # search for sccs
        sccs = networkx.algorithms.strongly_connected_components (g)
        sccs = [x for x in sccs if len (x) >= 2]
        debug (len (sccs), 'non-trivial scc(s) of size(s):')
        debug (', '.join (str(len (x)) for x in sccs) + '.')
        i = 0
        for x in sccs :
            debug (x)
            i = self.__conflicts_atom_scc (g.subgraph (x), f, i)
        if i :
            s = ''
            for j in xrange (i) : s += ',z%d' % j
            f.write ('ASSIGN ' + s[1:] + ';\n\n')
        debug ('done!')
        
    def __conflicts_atom_scc (self, g, f, i) :
#        debug ('generating unit path...')
        s = ''
        for (x, y) in g.edges () :
            assert (x != y)
            s += 'z%d:=e%d&e%d=>p%dx%d;\n' % (i, x, y, x, y)
            i += 1
        f.write (s)

#        debug ('generating asymmetry...')
        s = ''
        for x in g.nodes () :
            for y in g.nodes () :
                if x == y : continue
                s += 'z%d:=p%dx%d=>~p%dx%d;\n' % (i, x, y, y, x)
                i += 1
        f.write (s)

#        debug ('generating transitivity...')
        s = ''
        for x in g.nodes () :
            for y in g.nodes () :
                if x == y : continue
                for z in g[y] :
                    if x == z or z == y or z in g[x] : continue
                    s += 'z%d:=p%dx%d&p%dx%d=>p%dx%d;\n' % (i, x, y, y,
                            z, x, z);
                    i += 1
        f.write (s)

#        debug ('done!')
        return i

    def __conflicts_binary (self, g, f) :
        z = 0
        k = int (math.ceil (math.log (len (g.nodes ()), 2)))
        for (x, y) in g.edges () :
            f.write ('z%d := e%d & e%d => ord%dx%d;\n' % (z, x, y, x, y))
            z += 1
            i = k - 1
            s = 'ord%dx%d := ' % (x, y)
            while i > 0 :
                s += '(e%d%d & ~e%db%d) | ((e%db%d == e%db%d) & (' % (x, i, y,
                                i, x, i, y, i)
                i -= 1
            s += '(e%db0 & ~e%db0)' % (x, y)
            s += ''.join (')' for a in xrange (k)) + ';\n'
            f.write (s)

        assert (z)
        s = 'noconflicts := AND ('
        s += ', '.join ('z%d' % j for j in xrange (z))
        s += ');\n'
        f.write (s)


    def __conflicts_asym_graph (self, sym=True) :
        # build the asymmetric conflict relaton, excluding cutoffs
        g = networkx.DiGraph ()
        for e in self.events :
            if e == None or e.iscutoff : continue
            for c in e.pre :
                if c.pre : g.add_edge (c.pre.nr, e.nr)
                for ep in c.cont : g.add_edge (ep.nr, e.nr)
                if sym :
                    for ep in c.post :
                        if ep != e and not ep.iscutoff :
                            g.add_edge (ep.nr, e.nr)
                            g.add_edge (e.nr, ep.nr)
            for c in e.cont :
                if c.pre and not c.pre.iscutoff: g.add_edge (c.pre.nr, e.nr)

        s = 'with' if sym else 'without'
        debug ('graph:', len (g), 'nodes,', len (g.edges()), 'edges,', s, 'sym. confl.')
#        for (a, b) in g.edges () : debug ('edge', (a, b))
#        h = open ('/tmp/x.dot', 'w+')
#        todot (g, h)
#        h.close ()
        return g

    def __configuration_circuit (self, f) :

        # a configuration is free of cutoff-free cycles in the asymmetric
        # conflict
        debug ('generating conflict-free')
#        self.__conflicts_systematic (f)
        self.__conflicts_atom (f)
#        self.__conflicts_binary (f)

        # and causally closed
        debug ('generating causality')
        ll, s = [], ''
        for e in self.events :
            if e == None or e.iscutoff : continue
            l = set ([c.pre for c in e.pre + e.cont if c.pre])
            if not l : continue
            s += 'cc%d := e%d => AND (' % (e.nr, e.nr)
            s += ', '.join ('e%d' % e.nr for e in l)
            s += ');\n'
            ll.append (e.nr)
        if ll :
            s += 'ASSIGN '
            s += ', '.join ('cc%d' % x for x in ll)
            s += ';\n\n'
        f.write (s)
        debug ('done!')

    def deadlock_circuit (self, f) :
        f.write ('BC1.0\n\n')

        # nothing to do if there is zero cutoffs
        found = 0
        for e in self.events :
            if e and e.iscutoff : found = 1; break
        if not found :
            f.write ('t := T;\nASSIGN t;\n')
            return

        # models are configurations
        self.__configuration_circuit (f)

        # in which all events are disabled (including cutoffs)
        debug ('generating deadlock')
        i, l, s, tmp = 0, [], '', set ()
        for e in self.events :
            if e == None : continue
            a = frozenset (e.pre + e.cont)
            assert (a)
            tmp.clear ()
            for b in l :
                if a >= b : debug ('discarding', a); a = None; break
                if b < a : tmp.add (b)
            for b in tmp : l.remove (b)
            for b in tmp : debug ('removing', b)
            if a : l.append (a)
            if a : debug ('taking', a)
        tmp.clear ()
        for a in l :
            s += 'd%d := OR (' % i
            s += ', '.join ('~c%d' % c.nr for c in a) + ');\n'
            tmp |= a
            i += 1
        if i :
            f.write (s + 'ASSIGN ')
            s = ''
            for a in xrange (i) : s += ', d%d' % a
            s = s[2:] + ';\n\n'

        # and conditions are marked if pre and not post
        for c in tmp :
            s += 'c%d := ' % c.nr
            s += 'e%d' % c.pre.nr if c.pre else 'T'
            l = [e for e in c.post if not e.iscutoff]
            if l :
                s += ' & AND ('
                s += ', '.join ('~e%d' % e.nr for e in l)
                s += ')'
            s += ';\n'
        f.write (s)
        debug ('done!')

def test () :
    u = Unfolding ()
    e1 = u.add_event ('t1')
    e2 = u.add_event ('t2', iscutoff=True)
    assert e1.nr == 1
    assert e2.nr == 2

    c1 = u.add_cond ('p1', post=[1])
    c2 = u.add_cond ('p2', post=[1])
    c3 = u.add_cond ('p3', post=[2], cont=[1])
    c4 = u.add_cond ('p4', pre=1)
    c5 = u.add_cond ('p5', pre=1, post=[2])

    assert c1.nr == 1
    assert c2.nr == 2
    assert c3.nr == 3
    assert c4.nr == 4
    assert c5.nr == 5

    u.unf2dot (sys.stdout)
    for e in u.events[1:] : debug (e)
    for c in u.conds[1:] : debug (c)

#   f = open ('/tmp/x.dot', 'w+')
#   u.unf2dot (f)
#   f.close ()
#   print u.events
#   print u.conds

    for e in u.events[1:] : print e
    for c in u.conds[1:] : print c

def test1 () :
    l = [(0, 1), (1, 2), (2, 3), (3, 0), (3, 7), (7, 0), (3, 6), (2, 5),
        (5, 4), (4, 2), (1, 5)]

    g = networkx.DiGraph (l)
    networkx.algorithms.simple_cycles (g)

def todot (g, f) :
    f.write ('digraph {\n')
    for (a, b) in g.edges () : f.write (repr (a) + ' -> ' + repr (b) + '\n')
    f.write ('}\n')

def debug (*msg) :
    s = ' '.join (str(x) for x in msg)
    sys.stderr.write ('unf2bc: ' + s + '\n')

def main () :
    u = Unfolding ()
    u.cuf2unf (sys.stdin)
    u.deadlock_circuit (sys.stdout)

if __name__ == '__main__' :
#cProfile.run ('main ()')
    main ()

# vi:ts=4:sw=4:et:


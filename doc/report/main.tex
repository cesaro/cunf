
\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{mydefs}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{figlatex}
\usepackage{enumerate}
\usepackage{url}
%\usepackage[a4paper]{geometry}
\usepackage{a4wide}
\usepackage[top=3.8cm,bottom=3.6cm,right=3.3cm,left=3.3cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{remark}[theorem]{Remark}

\newcommand{\event}[1]{\ensuremath{\mathsf{event}(#1)}}
\newcommand{\hist}[1]{\ensuremath{\mathsf{Hist}(#1)}}
\newcommand{\origin}[1]{\ensuremath{\mathsf{origin}(#1)}}
\newcommand{\conf}[1]{\ensuremath{\mathsf{Conf}(#1)}}
\newcommand{\conds}[1]{\ensuremath{\mathsf{Conds}(#1)}}
\newcommand{\events}[1]{\ensuremath{\mathsf{Events}(#1)}}
\newcommand{\confl}{\ensuremath{\mathord{\#}}}
\newcommand{\evolves}{{\ensuremath{\ \sqsubseteq \ }}}
\newcommand{\devolves}{\evolves_{\!\!\!\uparrow}\;}

\newcommand{\peupdate}{\mbox{\sf pe\_update}}
\newcommand{\iscutoff}{\mbox{\sf is\_cutoff}}

\newcommand{\peupdatecont}{\mbox{\sf pe\_update\_context}}
\newcommand{\peupdatexisting}{\mbox{\sf pe\_update\_existing}}
\newcommand{\peupdatenew}{\mbox{\sf pe\_update\_new}}
\newcommand{\peupdategenhist}{\mbox{\sf pe\_update\_gen\_hist}}

%\setlength{\parskip}{0.3\baselineskip}
\begin{document}

\title{Implementation of a complete prefix unfolder for contextual nets}

\author{César Rodríguez\\[1ex]\textit{Under supervision of} Stefan Schwoon\\[1em]LSV -- ENS Cachan}
\date{August 2010}

\maketitle
%\pagestyle{empty} %
\thispagestyle{empty}

\subsection*{General context}

In\footnote{This work was supported by Fundación Caja Madrid under the grant
\emph{Beca de Postgrado Fundación Caja Madrid}.} the domain of
\emph{verification techniques} for \emph{concurrent systems}, and particularly
within the approach of \emph{state space methods}, the \emph{state explosion
problem} refers to the computational difficulty of exploring a representation
of the system's state space due to its intractably large size \rbib{EH08}.

Unfoldings are mathematical structures that can be used to explore the state
space of the system while being in some cases exponentially smaller than it.
Unfoldings were introduced for Petri nets by Nielsen, Plotkin and Winskel in
\rbib{NPW80}.  While a Petri net unfolding is usually infinite, McMillan
observed that a finite part of it can be effectively used for verification
purposes \rbib{MM92}.

In this work, we develop the first implementation of an unfolding tool
(unfolder) for \emph{contextual nets}, i.e., Petri nets extended with
\emph{read arcs}, following the abstract approach specified by Baldan et al. in
\rbib{BCKS08}.

\subsection*{The problem}

The goal of this work was providing the \emph{first implementation of the
theory of contextual net unfolding as presented in \rbib{BCKS08}}.  For that
purpose, we had to first define a concrete algorithm conforming to the abstract
specification provided in that reference.  In the development of the unfolder,
the first objective was \emph{correction of the tool}; secondarily,
\emph{performance}.

The main motivation for this work relies on the fact that the last aim of a
formal verification method should be that one of being used within some
verification tool.  Frequently, the first implementation of a theoretical
method brings new insights to the theory, that can in turn be used to refine
it.

The problem of contextual net unfoldings is not new (see above); the
implementation of the contextual unfolder do is.  We believe that our
contribution is original because we provide new algorithms that concretize the
abstract ones in \rbib{BCKS08}, as well as because our tool is, up to our
knowledge, the first contextual net unfolder.

\subsection*{The contributions}

In the practical arena, our main contribution is a 4700 lines of code
\emph{tool} written from scratch in C language, that is able to compute a
complete prefix of the full unfolding of a 1-safe contextual net.
Additionally, we have filled the gaps left by the abstract specification of the
unfolding algorithm of \rbib{BCKS08}, by providing a \emph{concrete algorithm},
as well as \emph{data structures} for representing the important objects
utilized by it.

Concerning the theory, we have integrated \emph{adequate} unfolding orders
\rbib{ERV96} in the framework of contextual unfoldings, proving finiteness of
the complete prefix.  Remaining extensions of the theory presented in this work
have been motivated by our aim to pave the way between \emph{theory and
implementation}.  We have characterized the notion of conflict between
configurations of the unfolding in terms of certain relation that can be
efficiently computed.  Finally, we have defined the notion of \emph{enriched
condition} and provided a characterization to compute efficiently a concurrency
relation on enriched conditions, in order to speed up the computation of the
unfolding.

\subsection*{Validity of the contributions}

It is a great asset of any implementation that one of becoming an
\emph{efficient} and \emph{reusable} piece of code.  Our tool, even if still in
need of some optimization, can accomplish the first target by means of the work
on concurrency relations on conditions that we have started.  Concerning
reusability, a maximum emphasis has been put in the isolation of the different
objects (events, conditions, histories, asymmetric conflict relation, etc.) and
algorithms operating on them (e.g. conflict between histories, computation of
possible extensions), leading to a very \emph{modular} implementation.
Additionally, our tool's input format is an extension of that one of the
PEP~project \rbib{PEP}, enabling certain compatibility with other tools.

Theoretical contributions have paved the way between theory and practice of
contextual net unfoldings.  For instance, we have suggested that the
\emph{direct} asymmetric conflict is an interesting notion with regards to the
implementation.  In the same way, our characterization of the concurrency
relation on enriched conditions (\rsec{optimizations}) is an starting point for
the optimization of our tool.

\subsection*{Evaluation and perspectives}

Performance of our tool is still low compared to other unfolders.  For
instance, on Petri nets (without read arcs) the Mole unfolder \rbib{MOLE} has
shown to operate one order of magnitude faster on certain examples.  Profiling
of our tool has pointed out that the bottleneck is located at the computation
of the \emph{possible extensions} to the prefix (\rsec{computation.possible}),
in particular due to a certain combinatorial blow up in the search of a
possible extension.  At this moment, our effort is focused on the discovery and
implementation of suitable \emph{concurrency relations} that can alleviate such
search procedure.  In summary, the application of the theory in \rbib{BCKS08}
in this work work has provided insights about where the optimization effort
should go.

Our general aim to make of our tool a competitive unfolder, and particularly
the research on concurrency relations commented above, will be the first steps
to pursue in the Ph.D of the author, starting at September 2010.

\newpage

\section{Introduction}
\label{sec:introduction}

% - 1 / 2 pages; they already know what a PN is
% - what an unfolding is; McMillan
% - for what it can be used; McMillan
% 	. planning
%	. encoding asynchronous circuits
%	. safety properties on finite state systems can be reduced to
%	reachability analysis 
% - contextual nets
% - unfolding contextual nets:
% 	. theory has been prsented in Baldan.
%	. PR encoding, other encodings; Baldan; then we use the normal
%	procedure
%	. but we can unfold into another contextual net
%	. each event no longer represents one run, but several
% 	. > are smaller than unfolding of the PR encoding
% 	. motivate this with 1 or 2 examples ??
% - motivation and goals
% 	. provide the first implementation of the theory
%	. such implementation is not an extension of other contextual unfolders
%	for PN; there are fundamental changes in the underlying theory w.r.t.
%	PN unfoldings
% 	. histories instead of local configurations
%	. there is 'meet enough' to write a new tool
%	. remark that the goal is to obtain a correct tool
%	. goal: fill the gaps in Baldan, provide a concrete algorithm out of
%	the abstract procedure specified there
% - contributions
% 	. to the theory
%		(+ fill the gaps in Baldan)
%		+ provided concrete procedures for the PE
%		+ finiteness and completeness proofs for adequate orders
%		+ concurrency relation on enriched conditions
% 	. to the implementation
%		+ implementation, 4kloc, from scratch
%		+ data structures
%		+ different exploration orders: McMillan, <F
% - outline

Petri nets are a formalism that has been fruitfully used for the modeling and
verification of concurrent systems.  They naturally make possible to express
notions such as concurrency, causality or conflict between actions or resources
\rbib{ERV96}.  Verification of safety problems for finite state Petri nets can
be reduced to reachability analysis, an approach that is feasible in practise
whenever we can avoid the state explosion problem.  net unfoldings are a
partial-order semantics initially introduced for Petri nets by Nielsen, Plotkin
and Winskel \rbib{NPW80}.

The unfolding of a Petri net is another particularly simple, acyclic Petri net
so called \emph{occurrence net}, that is behaviourally equivalent to the first.
While the unfolding is frequently infinite, McMillan noticed \rbib{MM92} that
it is still possible to build a finite prefix of it, containing information
enough to be useful for a given application.  Such a prefix is called
\emph{complete}, in the sense that it represents complete information of
the original net according to some criterion, for instance, reachable markings.
Finite and complete prefixes can be exponentially smaller than the full
reachability graph of the original Petri net, while being still adequate for
reachability analysis (in particular \emph{coverability}).  Other uses of
unfoldings include \emph{planning} \rbib{HRJSW07} or \emph{deadlock detection}
\rbib{MM92}.

\emph{Contextual nets} are Petri nets with \emph{read arcs}, i.e., arcs
allowing a transition to read a place and not consume it.  When interested in
reachability analysis, a contextual net can be translated into a Petri net by
replacing each read arc by a consume/produce loop.  The resulting net is
equivalent in terms of its reachability set, and can be unfolded through the
same procedure as for Petri nets.  However, such unfolding would explicitly
enumerate \emph{every} possible interleaving of all the transitions reading
from the same place, leading frequently to an explosion in size.  This blow up
can be avoided if we define the unfolding of a contextual net as another
\emph{contextual} net, whose construction procedure is a generalization of the
one for plain Petri nets.

Baldan et al. have proposed in \rbib{BCKS08} such a generalization.  In
particular, they present an abstract algorithm to compute a complete and finite
contextual prefix out of a contextual net.  In this work, we refine that
abstract algorithm and provide the first implementation of it.  Our contextual
unfolder consist on a 4700 line of code, C program, written from scratch.  The
main goals for this implementation were, in this order, correctness and
performance.

During the development of our unfolder, some inspiration was taken from the
Mole Petri net (without read arcs) unfolder \rbib{MOLE}.  However, Petri net
unfolding and contextual net unfolding are two tasks different enough so that
our unfolder could not be an extension of Mole.  This is due to the fact that
certain fundamental assumptions that can be done in Mole no longer holds in
contextual unfolding.  For instance, while each transition in a Petri net
unfolding implicitly represents \emph{only one} run of the original net, each
transition in a contextual unfolding represents a \emph{set} of runs, or
\emph{histories}, in the original net.  The existence of only one history per
event in the unfolding is a central assumption of Mole, that prevented us to
reuse most of its algorithms and data structures in our unfolder.  Arguments
similar to this one lead us to the development of a new tool from scratch.

Implementation of a contextual unfolder have favoured several other
contributions.  First and foremost, we provide a \emph{concrete algorithm and
implementation for the computation of the possible extensions} of the prefix
(see \rsec{computation.possible}); a \emph{data structure} for the
representation of histories is also provided (\rsec{history.graph}).
Concerning the theoretical framework, we generalize (and implement) the notion
of \emph{adequate order} \rbib{ERV96} from Petri net unfoldings to contextual
unfoldings and prove that the complete prefix is still finite (therefore
proving termination of our unfolder under this exploration order).  We
characterize the conflict relation $\confl$ between configurations (see
\rpag{pag:conflict}) in terms of the \emph{direct asymmetric conflict} relation
$\uparrow$ (see \rsec{direct.asymmetric}), a result of special relevance from
the point of view of the implementation.  Finally, as a mean to speed up the
computation of our unfolder, we define a \emph{concurrency relation} on
\emph{enriched conditions} (see \rsec{optimizations}).  Subsequently, we
characterize this relation in a suitable way that makes possible to use an
efficient construction method.  Unfortunately, we had no time to implement this
approach.

The reminder of the document is mainly divided in three sections.  In
\rsec{contextual.unfoldings}, we introduce contextual nets and their
unfoldings.  In \rsec{computing.unfolding}, we present the unfolding algorithm,
providing next from subsection \rsec{computation.possible} to
\rsec{optimizations} a detailed description of its auxiliary procedures and
data structures. In \rsec{implementation} we summarize how our unfolder has
been tested in order to guarantee its correctness.  Finally, some conclusions
and future research lines are drawn in \rsec{conclusions}.  Due to space
constrains, proofs are located in \rape{proofs}.

\section{Contextual unfoldings}
\label{sec:contextual.unfoldings}

We introduce in this section the class of contextual nets and its unfoldings.
We provide as well, in \rsec{challenging.aspects}, the motivations that led us
to the implementation of a new unfolder for contextual nets.

\subsection{Contextual nets}
\label{sec:contextual.nets}

% - def: contextual net; of Baldan
% 	- example
% - when no read arcs: PN
%
% - marking
% - enabled transition
% - firing
% - run
% - 1 safe; we restrict our interest to only 1-safe nets
%
% - 3 paragraphs: contextual unfolding; from McMillan
% - in general infinite, so we are interesting in a finite prefix that is
%   complete for some meaning of completeness; start with theory!
% - causality
% - asymmetric conflict
% - conflict relation, with example
% - configuration
% - marking associated to a run/configuration
% - some configurations are histories; history of a event in a config.
%
% - enriched event; enriched prefix
% - we search for a complete finite prefix; define completeness criterion
% - motivate why we need cutoffs, example, and definition of cutoff
% - truncation
% - finiteness and completeness of truncation
%
% - motivations why to write from scratch a new unfolder; what is challenging
% 	. remark what is challenging; there are fundamental changes; cannot be
%	an extension of the previous implementation
%	. conflict relation on events
%	. histories
%	. concurrency between conditions
%	. computation order; no longer $\subseteq$
%	. to know if a set is a configuration, it doesn't suffice to find a
%	pair of conflicting events


A \emph{contextual net} is a tuple $N = \langle P, T, F, C, m_0 \rangle$, where
$P$ and $T$ are disjoint sets respectively called \emph{places} and
\emph{transitions}, $F \subseteq P \times T \cup T \times P$ is the \emph{flow
relation}, $C \subseteq P \times T$ is the \emph{context relation} and $m_0 : P
\to \N$ is the \emph{initial marking}.  For $x \in P \cup T$, we denote by
$\pre x$ the \emph{preset} of $x$, defined as $\{y \in P \cup T \mid (y, x) \in
F\}$.  Similarly, the \emph{postset} of $x$, written $\post x$, is defined by
$\{y \in P \cup T \mid (x, y) \in F\}$.  Finally, for a transition $t \in T$ we
write $\cont t$ to denote the \emph{context} of $t$, defined as $\{p \in P \mid
(p, t) \in C\}$.  The same notation is used to denote the context of a place $p
\in P$, that is, the set $\{t \in T \mid (p, t) \in C\}$.

Note that contextual nets are an extension of traditional Petri nets.
Precisely, Petri nets are the class of contextual nets whose context relation
is empty.

A \emph{marking} $m$ is a function $m : P \to \N$ that maps every place of $P$
to a natural number, including 0. If for a marking $m$ and place $p$, $m(p) =
n$, then we say that $m$ marks $p$ with $n$ tokens.  If $\{0, \ldots, n\}$ is
the range of a marking $m$, we say that $m$ is $n$-safe.  We will associate,
without further comment, every 1-safe marking to a subset of $P$.

A transition $t \in T$ is said to be \emph{enabled} at a marking $m$ if $m$
marks every place of the preset and context of $t$ with at least one token,
i.e.,  if we have $m(p) > 0$ for $p \in \pre t \cup \cont t$.  Any transition
enabled at a marking can \emph{fire} (\emph{occur} or \emph{be executed}),
leading to a new marking.  Specifically, if $t$ is enabled at $m$, the
execution of $t$ at $m$ produces the new marking $$m'(p) = 
\begin{cases}
m(p) - 1 & \mbox{if } p \in \pre t \setminus \post t \\
m(p) + 1 & \mbox{if } p \in \post t \setminus \pre t \\
m(p) & \mbox{otherwise}
\end{cases}$$

A sequence of transitions that can fire one after other starting at the
initial marking $m_0$ is called a \emph{run}.  Formally, a finite sequence of
transitions $\sigma = t_1 \ldots t_n \in T^*$ is a run if there exist markings
$m_1, \ldots, m_n$ such that $t_1$ is enabled at the initial marking $m_0$ and
produces $m_1$ when fired at $m_0$, and for $2 \le i \le n$, transition $t_i$
is enabled at $m_{i-1}$ and produces $m_i$ when fired at $m_{i-1}$.  Marking
$m_n$ is said to be the marking reached by $\sigma$.  Conversely, a marking is
said to be \emph{reachable} if there exists some run in the contextual net that
reaches it.  The set of reachable markings of any contextual net $N$ is denoted
by $\markings N$.

By extension, a contextual net $N$ is said to be $n$-safe if every reachable
marking of $N$ is $n$-safe; it is said \emph{safe} if it is $n$-safe for some
natural number $n$.

\begin{figure}
\centering{\includegraphics{fig/a-1safe.fig}}
\caption{(a) A 1-safe contextual net. (b) A prefix of its full unfolding. (c)
The folding morphism.}
\label{fig:a.1safe}
\end{figure}

\rfig{a.1safe} (a) depicts a contextual net that is 1-safe.  Read arcs are
represented by means of undirected lines.  For $t_2$, we have that $\{p_1\} =
\pre{t_2}$, $\{p_3\} = \cont{t_2}$ and $\{p_4\} = \post{t_2}$.  The initial
marking is $\{p_1, p_2\}$ and $t_1, t_2, t_3$ is a run that reaches marking
$\{p_2, p_4\}$.  Marking $\{p_3, p_4\}$ is reachable because it is the marking
reached by the run $t_1, t_2$.

\paragraph{General assumptions}  We restrict our interest to finite 1-safe
contextual nets.  Precisely, when discussing the unfolding of some contextual
net $N = \langle P, T, F, C, m_0 \rangle$, we will assume $N$ to be 1-safe and
$P$, $T$, $F$ and $C$ finite.  We make two additional assumptions.  First, we
assume that no transition in $N$ has an empty preset, i.e., $\pre t \ne
\emptyset$ for all $t \in T$.  Second, we assume that for any transition $t \in
T$, its preset and context are mutually disjoint, i.e., $\cont t \cap \pre t =
\emptyset$.

\subsection{Unfolding contextual nets}
\label{sec:unfolding.contextual}

In order to provide an intuitive presentation of the unfolding of a contextual
net, let us first introduce the unfolding of a directed graph.  Consider a
directed graph $G$ and one node $v$ from $G$.  It is well known that one can
unfold $G$ into a labelled tree $U$ whose paths from the root node are in one
to one correspondence to the paths in $G$ starting from $v$.  A labelling $f$,
associating each node of $U$ to a node of $G$, implicitly provides this
correspondence.  Due to the tree-like structure of $U$, there is a natural well
founded precedence order on its nodes ($a$ precedes $b$ if so does in some path
from the root).

Construction of the tree is made recursively.  We start by appending to $U$ a
new node $u$ and updating $f$ with a new binding $f(u) = v$.  Then we regard
all nodes $v_1, \ldots, v_n$ in $G$ pointed by outgoing edges from $v$ and
append to $U$ new nodes $u_1, \ldots, u_n$, as well as the corresponding edges
from $u$.  The mapping $f$ is also updated with new bindings $f(u_1) = v_1,
\ldots, f(u_n) = v_n$.  This construction is next applied recursively to every
new node appended to $U$ in the previous step.  For this reason, the unfolding
operation naturally stops when no new node can be unfolded.  The resulting tree
$U$ is called the \emph{full} unfolding of $G$, and it is usually infinite.
The algorithm can also be stopped at an arbitrary point, yielding a finite
\emph{prefix} of the full unfolding.  \rfig{a.directed} illustrates a directed
graph (a) and a prefix of its full unfolding (b).

%\Ralg{directed.graph} describes with more detail this procedure.  Notice that
%the mapping $f$ is implicitly encoded the node set of $U$.  \Rfig{} illustrates
%its operation with a small graph its
%
%\begin{algorithm}
%\caption{Directed graph unfolding procedure}
%\label{alg:directed.graph}
%
%\begin{algorithmic}
%\REQUIRE $G = (V, E)$ and a node $v \in V$
%\ENSURE $U = (V', E')$, where $V' \subseteq V \times \N$
%
%\STATE $n = 1$ 
%\STATE $W = \emptyset$
%\STATE Add $\langle v, 0 \rangle$ to $W$
%\WHILE {$W \not= \emptyset$}
%\STATE Remove some $s = \langle u, n' \rangle$ from $W$
%\STATE Add $s$ to $V'$
%\FORALL {$(u, w) \in E$}
%\STATE Create new node $t = \langle w, n \rangle$
%\STATE $n := n + 1$
%\STATE Add $(s, t)$ to $E'$
%\STATE Add $t$ to $W$
%\ENDFOR
%\ENDWHILE
%\end{algorithmic}
%\end{algorithm}

\begin{figure}
\centering{\includegraphics{fig/a-directed.fig}}
\caption{A directed graph (a) together with an arbitrary prefix of its full
unfolding (b).}
\label{fig:a.directed}
\end{figure}

Following the same idea, a contextual net $N$ can also be unfolded into a
labelled \emph{contextual occurrence net} $\unf N$, that is, another contextual
net whose runs are in in one to one correspondence to the runs of the original
net.  A labelling, or folding morphism, consist on a pair of functions $\langle
f_T, f_P \rangle$ that associates each transition in $\unf N$ to a transition
in $N$ (through $f_T$) and each place of $\unf N$ to a place in $N$ (through
$f_P$).  Again, due to the acyclic and rooted structure of the contextual
occurrence net, there is a natural precedence (or causal) order on its
transitions and places.

Provided $N$, construction of $\unf N$, as well as $f_T$ and $f_P$, proceeds
incrementally, adding a new transition together with the places in its postset
at each step.  We start by appending to $\unf N$ a copy of the initial marking
of $N$, and updating $f_P$ to reflect this copy.  Then, we consider any
reachable marking $m'$ of $\unf N$ and compute its image $m$ though $f_P$ (that
is, a marking $m$ in $N$).  If any transition $t$ from $N$ is enabled at $m$
and no copy of $t$ firing from\footnote{To be precise, we should say 'firing
from the places in $\unf N$ whose image through $f_P$ conforms exactly the set
$\pre t$' in $N$, instead of 'firing from $m'$'.} $m'$ is still present in
$\unf N$, then a new copy of $t$ can be appended, as well as new copies of
places in $\post t$.  The folding morphisms are subsequently updated to reflect
the new transition and places in $\unf N$.  Mapping $f_T$ is updated with a
binding from the copy of $t$ to $t$, while mapping $f_P$ is updated to reflect
the copy of the postset of $t$.  The same procedure is repeated until no new
transition can be appended.  The resulting contextual net $\unf N$ is called
the \emph{full unfolding}, and it is usually infinite.  Nevertheless, the
procedure can be stopped at any point, yielding a finite \emph{prefix} of the
full unfolding.

The full unfolding $\unf N$, or any prefix of it, is a \emph{contextual
occurrence net}, a notion for which we will shortly give a formal definition.
Transitions of any contextual occurrence net will, from now, be called
\emph{events}, while its places will be called \emph{conditions}.
\rfig{a.1safe} illustrates a contextual net (a),  an arbitrary prefix of its
full unfolding (b) and the folding morphism (c).

The full unfolding $\unf N$ is infinite even for trivial examples (see
\rfig{a.1safe} (b)).  For this reason, we are interested in a prefix of $\unf
N$ large enough to be \emph{complete}, for some meaning of completeness.  In
particular, we are interested in computing a prefix whose reachable markings
are in one to one correspondence to the reachable markings of $N$.  In order to
define this prefix, we need to introduce some technical notions.  

For the reminder of this work, we will consider a 1-safe contextual net $N =
\langle P, T, F, C, m_0 \rangle$ and its full unfolding $\unf N = \langle P',
T', F', C', m'_0 \rangle$, together with the folding morphism $f_T : T' \to T$
and $f_P : P' \to P$.  We let variable $t$ to range transitions in $T$,
variable $p$ for places in $P$, variable $e$ for events in $T'$ and variable
$c$ for conditions in $P'$.

\begin{definition}
\label{def:causality.relation}
The \emph{causality relation} in $\unf N$ is the least transitive relation $<$
on $P' \cup T'$ verifying that, (1) if $c \in \pre e$, then $c < e$; (2) if $c
\in \post e$, then $e < c$; and (3) if $\post e \cap \cont{e'}$, then $e < e'$.
\end{definition}

Intuitively, relation $<$ captures the notion of \textit{what must occur first
in \emph{any} run of $\unf N$ that fires or marks some transition or place}.
For instance, regarding \rfig{a.1safe} (b), we have $c_3 < e_3$ since
\emph{any} run firing $e_3$ will first mark $c_3$ (notice that all the runs
that fire $e_3$ are prefixed by $e_1, e_3$ and $e_1, e_2, e_3$).  We also have
$c_2 < e_1$ as well as $e_1 < e_2$.

For any condition or event $x \in P' \cup T'$, we denote by $[x]$ the set of
\emph{causes} of $x$, i.e., the set $\{e \in T' \mid e \le x\}$, where $\le$ is
the reflexive closure of $<$.  For instance, $[c_4] = \{e_1, e_2\}$ and $[e_3]
= \{e_1, e_3\}$.

Consider now events $e_2$ and $e_3$.  We cannot say that \emph{any} run that
fires $e_3$ first fires $e_2$ (as $e_1, e_3$ is a run).  However, we can assure
that \emph{if some run fires $e_2$ and $e_3$, then it will fire $e_2$ before
$e_3$} (since once fired $e_3$, condition $c_3$ cannot be read).  This
situation arises due to the existence of read arcs and it is the cause of the
existence of several causal histories for certain events.  We characterize this
relation in the next definition.

\begin{definition}
\label{def:asymmetric.conflict}
We say that two events $e, e' \in T'$ are in \emph{asymmetric conflict}, and
write $e \nearrow e'$, iff either (1) $e < e'$, or (2) $\cont e \cap \pre{e'}
\not= \emptyset$, or (3) $e \not= e' \land \pre e \cap \pre{e'} \not=
\emptyset$.
\end{definition}

Let us see why the intuition in the previous paragraph holds in the three
sub-cases.  If $e < e'$, clearly any run that fires both events also fires
first $e$.  If $\cont e \cap \pre{e'} \not = \emptyset$ (the case of $e_2$ and
$e_3$ in \rfig{a.1safe} (b)), then if both $e$ and $e'$ are present in the same
run, $e$ must read its context before $e'$ consumes at least one place of it.
Finally, observe that if $e \not = e'$ and $\pre e \cap \pre{e'} \not =
\emptyset$, then $e$ and $e'$ cannot be present in the same run, and the
intuition vacuously holds.  However, this allows us to capture symmetric
conflicts\footnote{In a 1-safe Petri net (without read arcs), two transitions
are said to be in \emph{symmetric conflict} if they are different and share
some place in its respective presets.} by means of a loop of length two in the
asymmetric conflict relation.

For any set of events $X \subseteq T'$, we write $\nearrow_X$ to denote the
restriction of $\nearrow$ to $X$, that is, the relation $\nearrow \cap \ X
\times X$.

A \emph{contextual occurrence net} is any 1-safe contextual net $N'$ verifying
(1) $|\pre p| = 1$ for any place $p$ of $N'$; (2) $<$ is a strict partial order
and $[t]$ is finite for any transition $t$ of $N'$; (3) the initial marking of
$N'$ coincides with the set of places $p$ such that $\pre p = \emptyset$; and
(4) $\nearrow_{[t]}$ is acyclic for every transition $t$ of $N'$.  We assume
from now that $\unf N$ is a contextual occurrence net, enjoying therefore these
four properties.

The next important notion is that one of configuration:

\begin{definition}
A finite set of events $C \subseteq T'$ is a \emph{configuration} of $\unf N$
iff (1) $\nearrow_C$ is acyclic and (2) $C$ is causally closed, that is, for
all $e' < e$ with $e \in C$, we have $e' \in C$.
\end{definition}

Configurations characterize (concurrent) runs of $\unf N$.  A set of events is
a configuration iff all its events can be ordered to form a run.  Furthermore,
any permutation of the events of a configuration that conforms a run is
compatible with the asymmetric conflict relation $\nearrow$.  In \rfig{a.1safe}
(b), the set $\{e_1, e_2, e_3\}$ is a configuration, while the set $\{e_2\}$ is
not, since it is not causally closed.  We let $\conf{\unf N}$ denote the set of
all configurations of $\unf N$.

\label{pag:evolves} The \emph{computational order} $\evolves$ between
configurations captures the intuition that a configuration $C_1$ can evolve to
a configuration $C_2$ if $C_1 \subseteq C_2$ and all events $C_2 \setminus C_1$
can fire after $C_1$.  Formally, we define that $C_1 \evolves C_2$ holds
iff $C_1 \subseteq C_2$ and $\lnot (e_2 \nearrow e_1)$ for all $e_1 \in C_1$
and $e_2 \in C_2 \setminus C_1$ holds.

\label{pag:conflict} Additionally, two configurations are said to be in
\emph{conflict}, written $C_1 \confl C_2$, when either $\lnot (C_1 \evolves C_1
\cup C_2)$ or $\lnot (C_2 \evolves C_1 \cup C_2)$.  Intuitively, two
configurations are in conflict when they cannot evolve to a common
configuration.  Finally, note that if two configurations are \emph{not} in
conflict, then its union is a configuration.  The opposite is not necessarily
true.  Still in \rfig{a.1safe} (b), it holds that $\{e_1, e_2\} \evolves \{e_1,
e_2, e_3\}$, while it does not hold that $\{e_1, e_3\} \evolves \{e_1, e_2,
e_3\}$, since $e_2 \nearrow e_3$.  Therefore $\{e_1, e_3\} \confl \{e_1, e_2,
e_3\}$.

As any configuration $C$ is a run of $\unf N$, we can naturally associate to
$C$ the marking reached by that run.  We call that marking the \emph{cut} of
$C$.  In turn, any marking in $\unf N$ corresponds, via $f_P$, to a marking in
$N$.  We call this marking \emph{the marking} of $C$.  Still in \rfig{a.1safe}
(b), the marking of configuration $\{e_1, e_2\}$ is $\{p_3, p_4\}$, while its
cut is $\{c_3, c_4\}$.

\begin{definition}
Let $C$ be a configuration of $\unf N$.  We define the \emph{cut} of $C$,
written $\cut C$, and the \emph{marking} of $C$, written $\marking C$ as $$\cut
C = \left ( m \cup \bigcup_{e \in C} \post e \right ) \setminus \bigcup_{e \in
C} \pre e \qquad \qquad \qquad \marking C = \bigcup_{c \in \cut C} f_P (c)$$
\end{definition}

Some configurations are called \emph{histories}.  Intuitively, given a
configuration $C$ and some event $e \in C$, the history of $e$ in $C$ is the
subset of $C$ that contains $e$ as well as all events $e'$ that must fire
before $e$ in $C$, i.e., those for which $e' (\nearrow_C)^* e$ holds.

\begin{definition}
\label{def:history}
Let $C$ be a configuration of the $\unf N$ and $e \in C$ some event of $C$.
The \emph{history} of $e$ in $C$, written $C \sem e$, is the set $\{e' \in C
\mid e' (\nearrow_C)^* e\}$.  Additionally, we define the set of all histories
for any event $e \in T'$, written $\hist e$, as the set $\{C \sem e \mid C \in
\conf{\unf N} \land e \in C\}$.
\end{definition}

We use the notation $H_e$ to denote any history $H_e \in \hist e$ of $e$.
Every history $H_e$ is a configuration.  To see this, let $C$ be a
configuration and $e \in C$ some event such that $H_e = C \sem e$.  As $H_e
\subseteq C$, it is clear that $\nearrow_{H_e}$ is acyclic.  To show that $H_e$
is causally closed, assume that $e' \in H_e$ is some event of $H_e$ and that
$e'' < e'$.  Then we have $e'' \nearrow e' (\nearrow_C)^* e$.  As $e'' \in C$,
we have $e'' (\nearrow_C)^* e$ and therefore $e'' \in H_e$.

In a Petri net unfolding (without read arcs), any event $e$ can only
have one history (the so called \emph{local configuration} $[e]$, see
\rbib{MM92}).  The presence of read arcs gives rise to the existence of
multiple histories (or runs) per event, possibly infinite.  In \rfig{a.1safe}
(b), event $e_3$ have two histories, namely, $\{e_1, e_3\}$ (which coincides
with $[e_3]$) and $\{e_1, e_2, e_3\}$.


\subsection{A finite and complete prefix of $\unf N$}

Due to the fact that $\unf N$ is frequently infinite, we would like to define,
and then construct, a finite \emph{prefix} of $\unf N$ that is still
\emph{useful}.  A finite prefix of $\unf N$ is any contextual occurrence net
$\pref N$ that results from stopping at an arbitrary point the abstract
unfolding algorithm presented at the beginning of \rsec{unfolding.contextual}.
All the notions introduced so far in this document for $\unf N$ are likewise
applicable to any prefix $\pref N$.  Useful, or \emph{complete}, will mean in
this work that the prefix is large enough to represent exactly the same
reachable markings as $N$, that is, such that $$\markings N = \bigcup_{C \in
\conf{\pref N}} \marking{C}$$ Other definitions are possible, for instance, we
could require in addition that all runs of $N$ are represented in $\pref N$
\rbib{ERV96}.  Under our definition, it is clear that $\unf N$ is complete by
construction.

\begin{proposition}
\label{pro:unf.is}
The full unfolding $\unf N$ is complete.
\end{proposition}

In order to construct a finite and complete prefix of a Petri net (without read
arcs) unfolding, McMillan suggested to define certain events of the full
unfolding as \emph{cutoff} events, and let the unfolding algorithm to stop
either when no new event can be added or when any new event is a cutoff
\rbib{MM92}.  Then he proved that, for a proper definition of cutoff events,
his prefix was finite and complete.  Roughly, cutoff events were defined to be
those whose corresponding run (history, causal closure or \emph{local
configuration}) produces a marking that is reachable by a shorter run (firing
less events).  His definition of cutoff relies on the fact each event has
\emph{only one} history and cannot be adapted without changes to the framework
of contextual nets.

The natural generalization of this idea is to consider that cutoffs are, not
events, but \emph{enriched events}, that is, pairs $\langle e, H_e \rangle$
where $e$ is an event and $H_e \in \hist e$ is a history of $e$.  The unfolding
algorithm has also to be modified to compute, not a prefix of $\unf N$, but an
\emph{enriched prefix}, that is, a pair $\langle \pref N, \chi \rangle$ such
that $\pref N$ is a prefix of $\unf N$ and $\chi : T' \to 2^{\conf{\unf N}}$ is
a function associating to every event $e$ of $\pref N$ a non empty set of
histories of $e$ (that is, $\emptyset \not = \chi(e) \subseteq \hist{e}$),
additionally verifying\footnote{We impose this constrain on $\chi$ to conform
the definition of \emph{closed occurrence net} of \rbib{BCKS08}.  Intuitively,
this constraint forces the enriched prefix to be such that the history of any
event $e$ present in the prefix is the union of the histories associated events
$e'$ in asymmetric conflict to $e$.  Due to space constrains, we skip providing
a detailed motivation of this additional constraint and point the reader to
review Definition 12 of \rbib{BCKS08}.} that $H \in \chi (e)$ and $e' \in H$
implies $H \sem{e'} \in \chi (e')$.

Let us set some additional definitions. Let $\enr N = \langle \pref N, \chi
\rangle$ be an enriched prefix.  First, we set that a configuration $C$ of
$\enr N$ is any configuration $C \in \conf{\pref N}$ that verifies $C \sem e
\in \chi (e)$ for all $e \in C$.  The set of configurations of $\enr N$ is
denoted by $\conf{\enr N}$.  Second, we consider that, by extension, $\unf N$
\emph{is} the enriched prefix $\langle \unf N, \chi \rangle$ such that $\chi
(e) = \hist{e}$ for $e \in T'$.  Finally, we say that $\langle e, H_e \rangle$
is an enriched event \emph{of} $\enr N$, denoted by $\varepsilon \in \enr N$,
if $e$ is an event of $\pref N$ and $H_e \in \chi (e)$.  We let variable
$\varepsilon$ to range enriched events.  Now we can define a suitable
generalization of cutoffs for contextual nets.

\begin{definition}
\label{def:cutoff}
An enriched event $\langle e, H \rangle$ of $\unf N$ is called \emph{cutoff} if
either $\marking{H} = m_0$, the initial marking of $N$, or there exists another
enriched event $\langle e', H' \rangle$ of $\unf N$, so called the
\emph{corresponding event}, verifying $\marking H = \marking{H'}$ and $|H| <
|H'|$.
\end{definition}

\begin{figure}[t]
\centering{\includegraphics{fig/a-complete.fig}}
\caption{A complete enriched prefix (b) of \rfig{a.1safe} (a), together with an
incomplete one (a).}
\label{fig:a.complete}
\end{figure}

\rfig{a.complete} illustrates two enriched prefixes of the full unfolding of
\rfig{a.1safe} (a).  Histories associated to each event are depicted as sets
near the event.  The pair $\langle e_3, \{e_1, e_3\} \rangle$ is a enriched
event of (b), while it is not an enriched event of (a).  Regarding the enriched
prefix (b), imagine we remove history $\{e_1, e_2\}$ from $\chi (e_2)$.  The
resulting prefix would not conform the definition of enriched prefix, since,
setting $H = \{e_1, e_2, e_3\}$, we would have that $H \in \chi (e_3)$ and $e_2
\in H$ and not $H \sem{e_2} \in \chi (e_2)$, violating the condition stated on
$\chi$ in the definition of enriched prefix.  Finally, note that the enriched
prefix (b) is complete, while (a) is not.  Indeed, the marking $\{p_2, p_4\}$
is reachable in the original net, reachable in (b) through configuration
$\{e_1, e_2, e_3\}$ but unreachable in (a).  The two enriched events whose
event is $e'_1$ (depicted in gray in (b)) are cutoffs.  Precisely, enriched
event $\langle e'_1, \{e_1, e_3, e'_1\} \rangle$ is a cutoff because its
associated marking is the initial marking $\{p_1, p_2\}$.  Enriched event
$\langle e'_1, \{e_1, e_2, e_3, e'_1\} \rangle$ is a cutoff because its
associated marking $\{p_3, p_4\}$ is reachable by means of the smaller history
$\{e_1, e_2\}$.

The set of enriched prefixes of the full unfolding $\unf N$ is naturally
equipped with with an ordering.  Intuitively, enriched prefix $\enr N$ is a
\emph{prefix} of $\enr{N}'$ if the unfolding algorithm can append enriched
events to $\enr N$ to reach $\enr{N}'$.  Formally, enriched prefix $\enr N =
\langle \pref N, \chi \rangle$ is a prefix of $\enr{N}' = \langle \pref{N}',
\chi' \rangle$, written $\enr N \unlhd \enr{N}'$, iff $\pref N$ is a prefix of
$\pref{N}'$ and for all events $e$ in $\pref N$  we have $\chi (e) \subseteq
\chi' (e)$.

At this point, we can properly define the \emph{truncation} of the full
unfolding, that is, the greatest enriched prefix free of cutoffs, and state its
finiteness and completeness.

\begin{definition}
The \emph{truncation} of the full unfolding, denoted $\trunc N$, is the
greatest enriched prefix of $\unf N$, w.r.t. the $\unlhd$ ordering, which does
not contain any enriched event that is a cutoff.
\end{definition}

\begin{theorem}
\label{thm:trunc.has}
$\trunc N$ has a finite number of enriched events and is complete.
\end{theorem}

\subsection{Challenging aspects of contextual vs Petri net unfoldings}
\label{sec:challenging.aspects}

The main goal of this work is to provide an implementation of the unfolding
algorithm for contextual nets, presented in \rbib{BCKS08}.  The Mole
unfolder \rbib{MOLE} served as inspiration for the implementation of our
contextual unfolder, but almost\footnote{Only the routines to read the
description of the contextual net from a file could be reused, as the
contextual unfolder uses almost the same input format than Mole.} no code could
be reused from it.  In this section, we justify why our implementation is not
just an extension of Mole, but a new 4700 lines of code tool written from
scratch, by presenting the challenging aspects that arises when unfolding
contextual nets instead of Petri nets.

\begin{figure}
\centering{\includegraphics{fig/read-arcs.fig}}
\caption{Read arcs can lead to loops of arbitrary length in the $\nearrow$
relation.}
\label{fig:read.arcs}
\end{figure}

\paragraph{Conflict relation on events.}  A set of events are in
\emph{conflict} iff no configuration (or run) fires all them together.  Hence,
determining if a set is a configuration amounts to check that there is no
subset of events in conflict.  In Petri net unfoldings, this can be reduced to a
number of pairwise checks of events, relying on the fact that the (symmetric)
conflict relation is \emph{binary}.  In contextual net unfoldings, this is no
longer the case, as we have to check for a loop of \emph{any length} in the
(asymmetric) conflict relation.  \rfig{read.arcs} depicts a contextual net that
is equal to its own unfolding, in which we have the loop $e_1 \nearrow e_2
\nearrow e_3 \nearrow e_1$.  Events $e_1, e_2$ and $e_3$ are hence in conflict,
while any set of two events is free of conflict (and conforms a configuration).
Checking whether a set of events is a configuration is a central task of the
unfolding algorithm (see \rsec{computation.possible}) and can no longer be made
by checking for binary conflicts, as it is done in Mole.

\paragraph{Management of histories.}  While in the unfolding of a Petri net,
each event conceptually represents only one run (or history) of the original
net, in the unfolding of a contextual net, events correspond to more than one
run in the original net.  As the unfolding algorithm used in this work
explicitly keeps track of the set of histories associated to each event, we
need to implement data structures an algorithms to deal with certain operations
performed on histories (for instance duplicate test, or conflict test).  There
is no explicit notion (data structure or algorithm) of history in Mole that we
could reuse or extend.

\paragraph{Concurrency relation on conditions.}  In the unfolding of a Petri
net, each pair of conditions is either in \emph{causal} or \emph{concurrent} or
\emph{conflict} relation (see \S3.1 at \rbib{ERV96}) but never in two of these
relations at the same time.  In a contextual net unfolding, two conditions can
be in (asymmetric) conflict and still be marked by some marking (be
concurrent).  Conceptually, this prevents us from defining a concurrency
relation between conditions.  Existence of such relation is successfully
exploited in Mole to speed up the computation.  For contextual unfoldings, we
can still define a concurrency relation on \emph{enriched conditions} (see
\rsec{optimizations}), but again, we have to renounce to make an extension of
Mole and rather implement such relation from scratch.

\paragraph{Computational order $\evolves$ and asymmetric conflicts.}  The
computational order $\evolves$ is remarkably not only set inclusion between
configurations, but also requires to check certain conditions regarding the
asymmetric conflict relation (see definition in \rpag{pag:evolves}).  Our
current implementation needs to compute the relation $\evolves$ between
histories each time it extends the unfolding by one enriched event.  This
requires to explicitly store (a simplified version of) the asymmetric conflict
relation between events (see \rsec{direct.asymmetric}).  No need to store the
conflict relation is present in Mole.

\section{Computing the unfolding}
\label{sec:computing.unfolding}

In the previous section we presented a finite and complete enriched prefix
$\trunc N$ of the full unfolding $\unf N$ for a 1-safe contextual net $N$.  In
this section, we provide an algorithm to compute a possibly larger enriched
prefix $\fnr N$ that is still finite and complete.

Baldan et al. provide in \rbib{BCKS08} an abstract algorithm to compute $\fnr
N$.  In the sequel, we detail the data structures and algorithms used to
transform this abstract algorithm into a concrete one that can be directly
implemented.  Let us first introduce the data structure used to store $\fnr N$.
The unfolding procedure at \ralg{unfolding.procedure} outputs an enriched
prefix $\fnr N = \langle \pref N, \chi \rangle$, with $\pref N = \langle P',
T', F', C', m'_0 \rangle$ and $\chi : T' \to 2^{2^{T'}}$, by encoding the flow
and context relations $F'$ and $C'$ in the data structures used for $P'$ and
$T'$.  Each event $e$ is represented by means of a tuple $\langle M_p, M_c, t
\rangle$, with $M_p, M_c \subseteq P'$ and $t \in T$.  Set $M_p$ is the preset
of $e$, set $M_c$ is the context of $e$ and $t$ is the transition of $N$ to
which $e$ corresponds.  Each condition $c$ is stored by means of a tuple
$\langle e, p \rangle$, with $e \in T'$ being an event of $\pref N$ and $p \in
P$ the place of $N$ to which $c$ corresponds.  Note that the folding morphisms
$f_P$ and $f_T$ are also implicitly encoded in this data structure, and will be
assumed to be defined for the conditions and events currently present in the
prefix as the algorithm advances.  Finally, notice that in order to simplify
the algorithm, we make use of a special event $\bot$ whose postset is the
initial marking $m'_0$.  Event $\bot$ is \emph{not} mapped through $f_T$ to $N$
and is removed from $\fnr N$ at the end of the algorithm.

In \ralg{unfolding.procedure}, one realizes that two procedures remain
undefined, namely \peupdate{} and \iscutoff{}.  We provide a declarative
definition of \peupdate{} in \rsec{computation.possible}, while \iscutoff{} is
described here.  Procedure $\iscutoff (e, H)$ takes an enriched event as
argument and returns true if $\langle e, H \rangle$ is a cutoff, false
otherwise.  Precisely, $\iscutoff (e, H)$ returns true if it can find an event
$e'$ of $\fnr N$ and $H' \in \chi (e')$ such that $\marking{H'} = \marking{H}$
and $|H'| < |H|$, false otherwise\footnote{Note that \rdef{cutoff} declares
$\langle e, H \rangle$ as a cutoff if it has a corresponding event $\langle e',
H' \rangle$ in $\unf N$, not necessarily in $\fnr N$.  Our approach works
because we use a precise order when appending new enriched events to $\fnr N$.
In particular, this order assures that when we append an enriched event
$\langle e, H \rangle$, all enriched events $\langle e', H' \rangle$ of $\unf
N$ with $|H'| < |H|$ have already been appended to $\fnr N$.  For this reason,
if $\langle e, H \rangle$ has a corresponding event in $\unf N$, then that
event is already present in $\fnr N$.}.  It can be implemented by means of an
exhaustive search\footnote{However, we didn't implement it like that.  A more
elaborated version of it can be as follows:  we store a hash table mapping
$\marking{H_e}$ to $\varepsilon = \langle e, H_e \rangle$ for every
$\varepsilon$ of $\fnr N$.  When $\iscutoff (e, H)$ is called, we access the
hash table with $\marking{H}$.  If no entry can be found, we return false.
Otherwise, if $\langle e', H' \rangle$ is found, we return $H' < H$.} of such
$H'$ in the image of $\chi$.  

For the rest of this section, we let $\fnr N$ be the enriched prefix computed
by \ralg{unfolding.procedure}.  We let also $\enr N = \langle \pref N, \chi
\rangle$, with $\pref N = \langle P', T', F', C', m'_0 \rangle$ and $\chi : T'
\to 2^{2^{T'}}$, be the enriched prefix that results from \emph{stopping
\ralg{unfolding.procedure} at any arbitrary point}.  That is, $\enr N$ is any
intermediate state of the construction of $\fnr N$, and verifies $\enr N \unlhd
\fnr N$.

\begin{algorithm}
\caption{Unfolding procedure, see the text.}
\label{alg:unfolding.procedure}

\begin{algorithmic}
\REQUIRE A 1-safe contextual net $N = \langle P, T, F, C, m_0 \rangle$.
\ENSURE A finite and complete enriched prefix $\enr N = \langle \pref N, \chi
\rangle$ of the full unfolding of $N$, with $\pref N = \langle P', T', F', C',
m'_0 \rangle$ and $\chi : T' \to 2^{2^{T'}}$.

\vspace{1ex}
\STATE $T' = \{\bot\}$
\STATE $\chi (\bot) = \{\{\bot\}\}$
\STATE $m'_0 = \emptyset$
\STATE $m'_0 = m'_0 \cup \{\langle \bot, p \rangle\}$ for each $p \in m_0$
\STATE $P' = m'_0$

\STATE $E = \peupdate (\bot, \{\bot\})$
\WHILE {$E \not = \emptyset$}
\STATE Remove from $E$ some $\langle e, H \rangle$ minimal w.r.t $|H|$, and
assume that $e$ is $\langle M_p, M_c, t \rangle$
\IF{not $\iscutoff (e, H)$}
\STATE $T' = T' \cup \{e\}$
\STATE $\chi(e) = \chi(e) \cup \{H\}$
\STATE $P' = P' \cup \{\langle e, p \rangle\}$ for each $p \in \post t$
\STATE $E = E \cup \peupdate (e, H)$
\ENDIF
\ENDWHILE
\STATE Remove $\bot$ from $T'$ and remove the binding $\chi (\bot) =
\{\{\bot\}\}$.
\end{algorithmic}
\end{algorithm}

\subsection{Computation of the possible extensions}
\label{sec:computation.possible}

\ralg{unfolding.procedure} builds $\fnr N$ by starting from an empty enriched
prefix $\enr N$ and appending new enriched events to it, one at each iteration
of its unique loop.  Each enriched event that is a candidate to be appended to
$\enr N$ at any point in the construction of $\enr N$ is called a
\emph{possible extension}.  Intuitively, possible extensions are enriched
events of $\unf N$, currently not present in $\enr N$, that are \emph{enabled}
at the cut of some configuration of $\enr N$.

\begin{definition}
\label{def:possible.extension}
Given an enriched event $\varepsilon = \langle e, H \rangle$ of $\unf N$ that
is not an enriched event of $\enr N$, we call $\varepsilon$ a \emph{possible
extension} of $\enr N$ if $e = \langle M_p, M_c, t \rangle$, and $\pre t = f_P
(M_p)$, and $\cont t = f_P (M_c)$, and there is a configuration $C \in
\conf{\enr N}$ verifying $M_p \cup M_c \subseteq \cut C$ and $H = (C \cup
\{e\}) \sem e$.

Additionally, given an enriched event $\varepsilon = \langle e, H \rangle$ of
$\enr N$, a possible extension $\varepsilon' = \langle e', H' \rangle$ of $\enr
N$ is said to be \emph{induced by} $\varepsilon$ if $e \nearrow e'$ and $H
\subseteq H'$.
\end{definition}

In \ralg{unfolding.procedure}, the set $E$ stores the possible extensions of
$\enr N$.  Every new enriched event $\varepsilon$ appended to $\enr N$ inserts
at least one new configuration in $\enr N$, possibly rendering $E$ out of date,
as new enriched events may now be possible extensions enabled at the cut of
such configuration.  It is easy to see that any such event is a possible
extension induced by $\varepsilon$.  Procedure \peupdate{} returns the set of
possible extensions to $\enr N$ induced by the enriched event that it takes as
argument, and it is used to update $E$ after the addition of every new enriched
event.  Due to the space constraints, we present here a declarative definition
of \peupdate{}.  A pseudocode version of the procedure is presented in
\rape{algorithms}.

\begin{figure}[b]
\centering{\includegraphics{fig/possible-extensions.fig}}
\caption{(a) Possible extensions induced by $\langle e, H \rangle$. (b)
Computation of new histories for $e'$.}
\label{fig:possible.extensions}
\end{figure}

In order to compute the possible extensions induced by a given enriched event
$\langle e, H \rangle$, we consider enriched events $\langle e', H' \rangle$
with $e \nearrow e'$ (see \rfig{possible.extensions} (a)).  For such $e'$, we
compute a history $H'$ as the union of $\{e'\}$ and a family of histories
already present in $\enr N$.  That family, denoted by $\mathbf{F}_S$, will be a
set of histories whose union defines a configuration such that the cut
associated to that configuration marks the preset and context of $e'$.

More precisely, we enumerate all the tuples $e' = \langle M_p, M_c, t \rangle$
verifying that $f_P (M_p) = \pre t$, and $f_P (M_c) = \cont t$, and either
$\cont e \cap M_p \ne \emptyset$ or $\post e \cap (M_p \cup M_c) \ne
\emptyset$.  For each $e'$, we compute the sets of events $X = \pre{(M_p \cup
M_c)}$ and $Y = \cont{M_p}$ (see \rfig{possible.extensions} (b)).  Now, we
enumerate all subsets $S \subseteq Y$, and for each one we compute the set
$\mathbf{F}_S$, defined as the \emph{only} family of histories of the events $X
\cup S \cup \{e\}$ that verifies $$ \{H\} \subseteq \mathbf{F}_S \subseteq
\bigcup_{e'' \in X \cup S \cup \{e\}} \chi (e'') \qquad \mbox{and} \qquad
|\mathbf{F}_S \cap \chi(e'')| = 1 \mbox{ for all } e'' \in X \cup S \cup
\{e\}$$  In other words, $\mathbf{F}_S$ is a set of histories containing
history $H$, one history of \emph{each} $e_x \in X$ and one history of each
$e_y \in S$ (or, in other words, one history of \emph{some} $e_y \in Y$).
Finally, for each $\mathbf{F}_S$, we generate the enriched event $\langle e',
H'_S \rangle$, with $$H'_S = \{e'\} \ \cup \bigcup_{H'' \in \mathbf{F}_S} H''
\qquad \mbox{if} \qquad \lnot (H_1 \confl H_2) \mbox{ for all } H_1, H_2 \in
\mathbf{F}_S \quad \mbox{and} \quad \conc{M_p \cup M_c}$$  The fist condition,
$\lnot (H_1 \confl H_2)$ for all $H_1, H_2$, assures that $H'_S \setminus
\{e'\}$ is a configuration.  The second condition, $\conc{M_p \cup M_c}$,
verifies that $e'$ is enabled at $\cut{H'_S \setminus \{e'\}}$, and can be
easily computed by checking that no history $H'' \in \mathbf{F}_S$
consumes\footnote{We can say that a configuration (in particular, a history)
\emph{consumes} a condition if any run associated to the configuration so
does.} any condition of $M_p \cup M_c$.

The abstract presentation of \rbib{BCKS08} subtly omitted to specify explicitly
the second condition.  Led by this specification, our first version of the
contextual unfolder was incorrect.  Only exhaustive testing discovered the bug
in the \peupdate{} algorithm and led to a modification of the conditions being
computed by that procedure, resulting in the addition of the test $\conc{M_p
\cup M_c}$.  

\subsection{Direct asymmetric conflict}
\label{sec:direct.asymmetric}

According to \rdef{asymmetric.conflict}, any two events $e, e'$ of $\pref N$ in
causal relation, $e < e'$, are also in asymmetric conflict relation, $e
\nearrow e'$.  Transitivity of $<$ would lead to some difficulties if we were
interested in storing the $\nearrow$ relation.  Furthermore, our current
implementation of \peupdate{} uses the relation $\nearrow$ to compute the
relation $\confl$ between histories.  We show in the sequel how we can define,
store and use a simplified version of the asymmetric conflict relation that
provides, for our purposes, as much information as $\nearrow$.

\begin{definition}
\label{def:direct.asymmetric}
Given events $e$, $e'$ of $\unf N$, we say that $e$ is in \emph{direct
asymmetric conflict} to $e'$, and write $e \uparrow e'$, iff either
$\cont e \cap \pre{e'} \ne \emptyset$, or
$e \ne e' \land \pre e \cap \pre{e'} \ne \emptyset$, or
$\post e \cap \pre{e'} \ne \emptyset$ or
$\post e \cap \cont{e'} \ne \emptyset$
\end{definition}

\begin{figure}
\centering{\includegraphics{fig/the-graph.fig}}
\caption{(a) All possible cases of $e \uparrow e'$ in \rdef{direct.asymmetric}.
(b) The graph $\agr N$ and (c) the graph $\hst N$ for the (enriched) prefix of
\rfig{a.complete} (b).}
\label{fig:the.graph}
\end{figure}

\rfig{the.graph} (a) illustrates all cases of \rdef{direct.asymmetric}: for any
depicted $e'$, we have $e \uparrow e'$.  Observe also that, regarding
\rfig{possible.extensions} (a), we have $e \uparrow e'$ for all depicted $e'$.
Another characterization of $\uparrow$ is to say that $e \uparrow e'$ iff $e
\nearrow e'$ and $e < e' \implies \post e \cap (\pre{e'} \cup \cont{e'}) \ne
\emptyset$.  This means that relation $\uparrow$ is a subset of $\nearrow$ that
excludes the full relation $<$.  This is interesting from the point of view of
the implementation because computing and storing $\uparrow$ is easier than
$\nearrow$, while $\uparrow$ is still useful for our purposes, as we see now.
Let us define $C_1 \devolves C_2$ as $C_1 \subseteq C_2$ and $\lnot (e_2
\uparrow e_1)$ for all $e_1 \in C_1$ and all $e_2 \in C_2 \setminus C_1$.
Relation $\devolves$ uses $\uparrow$ instead of $\nearrow$ (see definition of
$\evolves$ at \rpag{pag:evolves}), but it is equivalent to $\evolves$:

\begin{proposition}
For any pair of configurations $C_1, C_2 \in \conf{\unf N}$, we have $C_1
\evolves C_2$ iff $C_1 \devolves C_2$.
\end{proposition}

We store the relation $\uparrow$ on events of $\pref N$ by means of a directed
graph $\agr N$, whose set of nodes coincides with the set of events of $\pref
N$ and whose set of edges contains a pair $(e, e')$ iff $e \uparrow e'$ (see
\rfig{the.graph} (b) for an example).  Whenever a new event $e$ is appended to
$\pref N$, we use \rdef{direct.asymmetric} to update $\agr N$.  This can be
done easily by considering the events reading or consuming $\pre e$ and $\cont
e$.  

\subsection{History graph}
\label{sec:history.graph}

\ralg{unfolding.procedure} needs to deal with enriched events $\langle e, H
\rangle$ of $\enr N$.  We now describe a data structure to store the history
$H$ of such enriched events, as well as the mapping $\chi$.

A naive implementation could represent every history by means of the list of
events contained in it.  Naturally, this would lead to a bottleneck as the
prefix $\enr N$ \textit{grows} and histories are larger.  We take advantage of
the fact that each history $H$ is the union of $\{e\}$ with a set of histories
$H_{e'}$ for events $e' \uparrow e$, as explained in
\rsec{computation.possible}.  We represent $H$ by means of a node in the so
called \emph{history graph}.

\begin{definition}
For a given enriched prefix $\enr N$, we define the \emph{history graph} $\hst
N = (V, \to)$ as the directed graph whose set of nodes $V$ coincides with the
set $\{\langle e, H \rangle \mid e \in T' \land H \in \chi (e)\}$ of enriched
events of $\enr N$, and whose edges are pairs $\langle e, H \rangle \to \langle
e', H' \rangle$ iff $e' \in H$, and $e' \uparrow e$ and $H' = H \sem{e'}$.
\end{definition}

Graph $\hst N$ stores one node for every enriched event of $\enr N$.  The edge
relation $\to$ is closely related to the way in which possible extensions are
computed.  Regarding again \rfig{possible.extensions} (b), each (new) history
$H'_S$ is the union of $\{e'\}$ with one history $H_{e_x} \in \chi (e_x)$ for
each $e_x \in X$ and one history $H_{e_y} \in \chi (e_y)$ for each $e_y \in S$.
Grabbing the same structure, $\hst N$ keeps one edge $\langle e', H'_S \rangle
\to \langle e_x, H_{e_x} \rangle$ for each $e_x \in X$ and one edge $\langle
e', H'_S \rangle \to \langle e_y, H_{e_y} \rangle$ for each $e_y \in S$.  This
gives rise to the next lemma.

\begin{lemma}
\label{lem:given.hst}
Given $\hst N = (V, \to)$ and $\varepsilon = \langle e, H \rangle \in V$, we
have $H = \{e' \in T' \mid \varepsilon \to^* \langle e', H' \rangle\}$.
\end{lemma}

\rlem{given.hst} basically says that, given any node $\varepsilon$ of $\hst N$,
we can build the history that it represents by computing the set of events $e'$
such that $\varepsilon \to^* \langle e', H' \rangle$.  Let $r \colon V \to
2^{T'}$ be the function that maps each node $\varepsilon$ of $\hst N$ to the
set $r (\varepsilon) = \{e' \in T' \mid \varepsilon \to^* \langle e', H'
\rangle\}$.  Function $r$ can be be easily implemented by means of a search
procedure on $\hst N$.

Our unfolder implements the mapping $\chi$ by means of the graph $\hst N$ and a
list $l_e$ of nodes of $\hst N$ associated to each event $e \in T'$.  In order
to enumerate $\chi (e)$, it suffices to enumerate $l_e$.  In order to enumerate
the events in the history of some node $\varepsilon$ of $\hst N$, we return the
set $r(\varepsilon)$.

\subsection{Cutoff criterion and adequate orders}
\label{sec:cutoff.criterion}

The cutoff criterion (\rdef{cutoff}) is the key factor that makes the
truncation $\trunc N$ a finite and complete prefix.  Other cutoff criteria are
possible, still leading to a finite and complete prefix.  Esparza et al.
proposed in \rbib{ERV96} the notion of \emph{adequate order} on configurations
of $\unf N$, that is, a characterization of the orders for which we can
reformulate the definition of cutoff in such a way that the proof of finiteness
and completeness of $\trunc N$ still works.  We provide now a generalization
for contextual nets:

\begin{definition}
\label{def:adequate.order}
A partial order $\prec$ on $\conf{\unf N}$ is called \emph{adequate} iff (1)
$\prec$ is well founded, and (2) $C_1 \sqsubset C_2$ implies $C_1 \prec C_2$,
and (3) $\prec$ is preserved by finite extensions, that is, if $C_1 \prec C_2$,
and $\marking{C_1} = \marking{C_2}$, and $C_1 \sqsubset C_1 \cup E$ for some
extension $E$ of $C_1$, and $C_2 \sqsubset C_2 \cup E'$ for some extension $E'$
isomorphic to $E$, then $C_1 \cup E \prec C_2 \cup E'$.
\end{definition}

In \rbib{ERV96}, adequate orders are defined for Petri nets.  Every adequate
order as defined in \rbib{ERV96} is an adequate order as defined in
\rdef{adequate.order}, which intuitively means that our definition is more
general.  Briefly, this holds because $C_1 \sqsubset C_2$ implies $C_1 \subset
C_2$.

We can redefine now the notion of cutoff according to any order on $\conf{\unf
N}$ that is adequate.  We call \emph{adequate cutoff} to any enriched event
$\langle e, H \rangle$ of $\unf N$  if either $\marking H = m_0$, the initial
marking of $N$, or there exists another enriched event $\langle e', H' \rangle$
of $\unf N$ verifying $\marking H = \marking{H'}$ and $H \prec H'$ for some
adequate order $\prec$.  In the same way, we can redefine the truncation of the
full unfolding.  The \emph{adequate truncation}, denoted by $\atrunc N$, is the
greatest enriched prefix of $\unf N$, w.r.t. the $\unlhd$ ordering, free of
adequate cutoffs.  Under this notion of cutoff, we can still prove the
finiteness and completeness of $\atrunc N$:

\begin{theorem}
\label{thm:atrunc.has}
$\atrunc N$ has a finite number of enriched events and is complete.
\end{theorem}

The so called McMillan order ($C_1 \prec C_2$ iff $|C_1| < |C_2|$) is adequate.
This is the order used in \rbib{BCKS08} as well as on
\ralg{unfolding.procedure} and the definition of \iscutoff{}.  For our
unfolder, we also implemented the order $\prec_F$ of \rbib{ERV96}, which, due
to space constraints we cannot present here.

\subsection{Optimizations}
\label{sec:optimizations}

Experimental verification has shown that the bottleneck in
\ralg{unfolding.procedure} is located in the computation of the possible
extensions to $\enr N$, in particular in the computation of the $\confl$
relation.  Roughly speaking, code profiling has pointed out that our tool
spends in average 85\% of the time computing the relation $\confl$.  We propose
now an optimization of procedure \peupdate{} that could speed up the unfolding
algorithm.

In a Petri net unfolding, it is possible to define a \emph{binary} concurrency
relation $R$ on the unfolding conditions.  Then, it is possible to determine if
a number of conditions are concurrent by checking whether \emph{every} pair of
conditions is in $R$.  Such approach is successfully exploited by Mole to speed
up the computation of the unfolding.  Unfortunately, this idea cannot be used
without modifications in the framework of contextual unfoldings.  We can
nevertheless define a concurrency relation, not on conditions, but on enriched
conditions.

An \emph{enriched condition} of $\enr N$ is a pair $\rho = \langle c, H
\rangle$ such that either $H = \emptyset$ and $c \in m'_0$, the initial marking
of $\enr N$, or there is an enriched event $\langle e, H \rangle$ of $\enr N$
verifying $c \in \post e \cup \cont e$.  We denote by $\rho \in \enr N$ the
fact that $\rho$ is an enriched condition of $\enr N$.  We need some notation
to work with enriched conditions and events.  We define the \emph{preset} $\pre
\rho$ of an enriched condition $\rho = \langle c, H \rangle \in \enr N$ as the
set $\{\langle e, H' \rangle \in \enr N \mid H' \in \chi (e) \land H' = H\}$.
Additionally, we define the \emph{preset} $\pre \varepsilon$ and \emph{context}
$\cont \varepsilon$ for an enriched event $\varepsilon = \langle e, H \rangle
\in \enr N$ as, respectively, the sets $\{\langle c, H' \rangle \in \enr N \mid
c \in \pre e \land \exists e' \in H \mbox{ maximal w.r.t.} \nearrow_H \land H'
= H \sem{e'}\}$ and $\{\langle c, H' \rangle \in \enr N \mid c \in \cont e
\land \exists e' \in H \mbox{ maximal w.r.t.} \nearrow_H \land H' = H
\sem{e'}\}$.

We define now the binary \emph{concurrency relation} on enriched conditions
$\rho = \langle c, H \rangle$, $\rho' = \langle c', H' \rangle$ of $\enr N$ as
$$ \rho \parallel \rho' \bydef\iff \lnot (H \confl H') \land \{c, c'\}
\subseteq \cut{H \cup H'}$$  That is, $\rho$ is concurrent to $\rho'$ if its
histories are not in conflict, and $H$ does not consume $c'$ and $H'$ does not
consume $c$.  Relation $\parallel$ enjoy the property that any set of
conditions $\{c_1, \ldots, c_n\}$ is concurrent iff there exist enriched
conditions $\langle c_1, H_1 \rangle, \ldots, \langle c_n, H_n \rangle$
verifying $\langle c_i, H_i \rangle \parallel \langle c_j, H_j \rangle$ for $1
\le i < j \le n$.  We believe that is remarkably interesting from the point of
view of the implementation, since we conjecture that can use $\parallel$ to
speed up the computation of \peupdate{} in the same way as it is done in Mole.

In order to use $\parallel$ for the computation of \peupdate{}, one alternative
is to store $\parallel$ for \emph{every} pair of enriched conditions currently
present in $\enr N$ and to update the relation whenever new enriched conditions
$\rho$ are appended to $\enr N$.  Furthermore, it is possible to compute the
update of $\parallel$ by computing $\rho \parallel \rho'$ for each $\rho$ newly
appended to $\enr N$ and every $\rho'$ already present in $\enr N$
\emph{without computing $H \confl H'$}. This can be done by means of the next
equivalence.

\begin{theorem}
\label{thm:two.different}
Let $\rho = \langle H, c \rangle$, $\rho' = \langle H', c' \rangle$ be two
different enriched conditions of $\enr N$ such that $H \in \chi(e)$, $H' \in
\chi(e')$ and $H' \prec H$ for an adequate order $\prec$.  We have the
equivalence $$\rho \parallel \rho' \iff \bigwedge_{\rho_i \in \pre{\pre\rho}}
\rho_i \parallel \rho' \; \land \; \bigwedge_{\sigma_j \in \cont{\pre\rho}}
\sigma_j \parallel \rho' \; \land \; (\rho' \notin \pre{\pre \rho}) \; \land \;
\lnot \exists e'' \in H' \setminus H,\, \cont{e''} \cap \pre e \not=
\emptyset$$
\end{theorem}

To understand the practical utility of this equivalence, assume that $\langle
e, H \rangle$ is the last possible extensions appended to $\enr N$.  This
triggered the addition of enriched conditions $\rho = \langle c, H \rangle$
with $c \in \post e \cup \cont e$.  At this point, we use \rthm{two.different}
to compute and subsequently store $\rho \parallel \rho'$ for every $\rho'$
already present in $\enr N$.  We compute $\rho \parallel \rho'$ by means of a
boolean conjunction that regards the previously computed results of $\rho_i
\parallel \rho'$ and $\sigma_j \parallel \rho'$ for certain enriched conditions
$\rho_i$ and $\sigma_j$, as well as other logical conditions, that are also
easy to compute, considering the internal data structures of our unfolder.

The ability to use the relation $\parallel$ to compute sets of concurrent
conditions as well as the fact that it can be computed incrementally as $\enr
N$ grows make from $\parallel$ an interesting optimization that has not been,
for the time being, implemented into our unfolder due to time constraints.

% - Baldan et al present the algorithm in an abstract way
% - Contents of the section
% - Brief explanation of data structures: events + conditions + encoding of fP,
%   fT, F', C'
% - Notation. Assume Pref N = P' T' F' C' m'0 is encoded by P', T' and m'0, as
%   well as functions fP and fT; bottom is a new event not associated to any
%   transition
% - Algorithm
% - \peupdate
%	- Lemma stating what peupdate does
%	- We need a way to avoid a systematic enumeration of all the
%	  configurations of the prefix
%	- Baldan proposes to define \#; two histories with no conflict
%	  form a configuration; then you can use that check for configurations
%	  using the histories of transitions generating Mp and Mc.  It is not
%	  said in the article that transitions in Mp and Mc have to be in
%	  the cut of the union of histories.
%	- Initial implementation of the unfolder was incorrect due to this
%	  subtlety.  Subsequent test discovered the bug and lead to a
%	  modification of the criterion to uncover new histories:
%	- We define enriched conditions and $\parallel$ on them as ...
%	- Present the algorithms; this is a contribution
%	- They still generate duplicate enriched events, we have to check for
%	  it
% - History graph
%	[ . check what happens with the duplicates ]
% 	. purpose
%	. presentation
%	. some lemma?
% - Adequate order
% 	. why it still works (wrt. the one proposed by Baldan), intuitions
%	. termination and completeness
% - Asymmetric conflict relation
% 	. relation used instead of the asymmetric conflict relation
%	. why it works (a lemma)
% - Optimizations
% 	. $\rho \parallel \rho'$; other lines of research (buscar esquema de
%	posibles lineas que me hizo una vez)

\section{Implementation testing}
\label{sec:implementation}

As stated in the introduction, our first priority while implementing the
unfolding algorithm was correction.  The second, performance.  We present here
some of the tests that have been performed to the tool.

One of our problems was to know if the unfolding prefix generated after the
computation was complete or not.  When testing under toy examples, this can be
check by hand, but this is no longer the case when the examples are big.  We
addressed this problem in two different ways.

We made profit of the existence of the Petri net unfolder Mole.  Mole is able
to compute a compete unfolding prefix for a Petri net, without read arcs.  We
developed a small tool to check whether two given Petri nets are isomorphic,
and compared the resulting prefixes when unfolding the same Petri net with both
unfolders.  We can assure that for all the (trivial and non trivial) examples
provided by the PEP~Project \rbib{PEP}, the output of our unfolder is a prefix
isomorphic to the prefix generated by Mole.

Of course, Mole cannot unfold contextual nets.  In order to check our unfolder
on Petri nets with read arcs, we developed another tool able to compute the
reachability set of any 1-safe net.  We then applied it to a set of examples
and its unfoldings obtained through our tool.  In all the cases the
reachability set of the example and its unfolding was the same.

%\FIXME{Write down or remove!}
% - Why from scratch
% - I/O formats
% - (Particular design of some component, if it's of interest)
% - Correction and testing
%	. some of the algorithms implement definitions 'as is', without further
%	optimizations
%	. tests performed to validate the tool: isomorphism, reachability
%	. results of some experiment; at least comment on the sizes of the
%	nets, describe something about the experimentation done

\section{Conclusions and future work}
\label{sec:conclusions}

In this work, we address the problem of unfolding 1-safe contextual nets.  In
particular, we tackle the implementation of an unfolder that generates a
complete and finite prefix following the abstract unfolding method specified in
\rbib{BCKS08}.  Our work constitutes the first implementation of such method,
and its development required attention to practical as well as theoretical
matters.

On the practical side, we have developed a working contextual unfolder.  We
have proposed data structures to support the manipulation of the notions
involved in the unfolding procedure, such as the history graph or the direct
asymmetric conflict graph.

On the theoretical arena, we have also provided several contributions.  We have
suggested a generalization of adequate orders for contextual unfoldings, and
subsequently proved how we can still use them to build a finite and complete
prefix.  A concurrency relation on enriched conditions has also been suggested,
but not implemented.  This relation has subsequently been characterized so as
to allow the relation itself to be updated as the unfolding grows.  Similar
ideas have successfully been used in Mole, a Petri net (without read arcs)
unfolder, which suggests that this could be an interesting avenue.

The implementation of the contextual unfolder showed to be non trivial (4700
lines of C code).  With the goal of soundness in mind, and whenever possible,
several theoretical notions were translated into an implementation by turning
the theoretical notion \emph{as is} into an algorithm.  This is remarkably the
case of the conflict relation $\confl$ between histories, where the unfolder
spends in average more than 85\% of the time.  Consequently, we do not reach
still the performance of Mole.  Further work is required to review certain data
structures and algorithms, such as the relation $\confl$.  We hope that this
will allow our unfolder to treat moderately larger examples than the current
ones.

Concerning the applications, Mole has been applied in the domains of model
checking and planning \rbib{HRJSW07}.  We plan to pursue similar lines of
application with our tool.


% - Summary
% 	. We address the problem of unfolding 1-safe contextual nets...
%	. In particular, the implementation of the algorithm Baldan ...
%	. We have defined a concrete procedure following the abstract
%	especification of ...
%	. Also the data structures, siendo las más remarcables el grafo de
%	historias y el conflicto directo asimetrico
%	. We have also provided several contributions to the theory, adequate
%	orders, parallel relation
% - (Concerning the implementation)
% 	. We have implemented a contextual unfolder of 4.7KLOC, in C
%	. Goal was soundness, in most places the definition is implemented as
%	is
%	. We don't reach the performance of mole, more optimization is required
%	. But we know where the problem is (PE)
%	. Still small examples (< 10 pow 6 events)
%
% - Search for applications
% 	. Copiar frase del research proposal:
%	. Model checking and planning
%	. Need to investigate in concurrency relations
% - Future work in phd
%	- In general, work should go to the PE computation
% 	- More optimization, concurrency relations

\nocite{*}
\bibliographystyle{plain}
\bibliography{biblio} % -> biblio.bib

\include{appendix}

\end{document}

 % vim:syn=tex:spell:

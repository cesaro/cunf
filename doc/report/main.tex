
\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{mydefs}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{figlatex}
\usepackage{enumerate}
%\usepackage[a4paper]{geometry}
\usepackage{a4wide}
%\usepackage[right=3.4cm,left=3.4cm]{geometry}

\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{remark}{Remark}

\newcommand{\event}[1]{\ensuremath{\mathsf{event}(#1)}}
\newcommand{\hist}[1]{\ensuremath{\mathsf{Hist}(#1)}}
\newcommand{\origin}[1]{\ensuremath{\mathsf{origin}(#1)}}
\newcommand{\conf}[1]{\ensuremath{\mathsf{Conf}(#1)}}
\newcommand{\conds}[1]{\ensuremath{\mathsf{Conds}(#1)}}
\newcommand{\events}[1]{\ensuremath{\mathsf{Events}(#1)}}
\newcommand{\confl}{\ensuremath{\mathord{\#}}}
\newcommand{\evolves}{{\ensuremath{\ \sqsubseteq \ }}}

\newcommand{\peupdate}{\mbox{\sf pe\_update}}
\newcommand{\iscutoff}{\mbox{\sf is\_cutoff}}

\newcommand{\h}{\ensuremath{\mathcal{H}}}
\newcommand{\pe}{{\sc PE}}
\newcommand{\peupdatecont}{{\sc PE-Update-Context}}
\newcommand{\peupdatepostexisting}{{\sc PE-Update-Postset-Existing}}
\newcommand{\peupdatepostnew}{{\sc PE-Update-Postset-New}}
\newcommand{\pehistdup}{{\sc PE-History-Duplicated}}
\newcommand{\peeventdup}{{\sc PE-Event-Duplicated}}

%\setlength{\parskip}{0.3\baselineskip}
\begin{document}

%\title{Implementation of an unfolder for the McMillan's complete prefix for contextual nets}

\title{Implementation of a complete prefix unfolder for contextual nets}

\author{César Rodríguez\\Stefan Schwoon\\LSV -- ENS Cachan}
\date{July 2010}

\maketitle
\pagestyle{empty} %
\thispagestyle{empty}

%% Attention: pas plus d'un recto-verso!
% Ne conservez pas les questions

\subsection*{General context}

De quoi s'agit-il ? 
D'où vient-il ? 
Quels sont les travaux déjà accomplis dans ce domaine dans le monde ?

\subsection*{The problem}

Quelle est la question que vous avez abordée ? 
Pourquoi est-elle importante, à quoi cela sert-il d'y répondre ?  
Est-ce un nouveau problème ?
Si oui, pourquoi êtes-vous le premier chercheur de l'univers à l'avoir posée ?
Si non, pourquoi pensiez-vous pouvoir apporter une contribution originale ?

\subsection*{The contributions}

Qu'avez vous proposé comme solution à cette question ? 
Attention, pas de technique, seulement les grandes idées ! 
Soignez particulièrement la description de la démarche \emph{scientifique}.

\subsection*{Validity of the contributions}

Qu'est-ce qui montre que cette solution est une bonne solution ?
Des expériences, des corollaires ? 
Commentez la \emph{robustesse} de votre proposition : 
comment la validité de la solution dépend-elle des hypothèses de travail ?

\subsection*{Evaluation and perspectives}

Et après ? En quoi votre approche est-elle générale ? 
Qu'est-ce que votre contribution a apporté au domaine ? 
Que faudrait-il faire maintenant ? 
Quelle est la bonne \emph{prochaine} question ?

\newpage
\section{Introduction}

 - 1 / 2 pages; they already know what a PN is
 - what an unfolding is; McMillan
 - for what it can be used; McMillan
 	. planning
	. encoding asynchronous circuits
	. safety properties on finite state systems can be reduced to
	reachability analysis 
 - contextual nets
 - PR encoding, other encodings; Baldan
 - contextual unfoldings
 	. are smaller than unfolding of the PR encoding
 	. motivate this with 1 or 2 examples,
 - motivation and goals
 	. histories instead of local configurations
	. there is 'meet enough' to write a new tool
	. remark that the goal is to obtain a correct tool
 - contributions
 	. to the theory
		+ fill the gaps in Baldan
		+ adequate orders
 	. to the implementation
		+ implementation, 4kloc, from scratch
 - outline

\section{Contextual unfoldings}

We introduce in this section the definitions of contextual net, unfolding and
provide the motivations to \FIXME{ocuparse} of the implementation of a new
unfolder for contextual nets.

\subsection{Contextual nets}

% - def: contextual net; of Baldan
% 	- example
% - when no read arcs: PN
%
% - marking
% - enabled transition
% - firing
% - run
% - 1 safe; we restrict our interest to only 1-safe nets
%
% - 3 paragraphs: contextual unfolding; from McMillan
% - in general infinite, so we are interesting in a finite prefix that is
%   complete for some meaning of completeness; start with theory!
% - causality
% - asymmetric conflict
% - conflict relation, with example
% - configuration
% - marking associated to a run/configuration
% - some configurations are histories; history of a event in a config.
%
% - enriched event; enriched prefix
% - we search for a complete finite prefix; define completeness criterion
% - motivate why we need cutoffs, example, and definition of cutoff
% - truncation
% - finiteness and completeness of truncation
%
% - motivations why to write from scratch a new unfolder; what is challenging
% 	. remark what is challenging; there are fundamental changes; cannot be
%	an extension of the previous implementation
%	. conflict relation on events
%	. histories
%	. concurrency between conditions
%	. computation order; no longer $\subseteq$
%	. to know if a set is a configuration, it doesn't suffice to find a
%	pair of conflicting events


A \emph{contextual net} is a tuple $N = \langle P, T, F, C, m_0 \rangle$, where
$P$ and $T$ are disjoint sets respectively called \emph{places} and
\emph{transitions}, $F \subseteq P \times T \cup T \times P$ is the \emph{flow
relation}, $C \subseteq P \times T$ is the \emph{context relation} and $m_0 : P
\to \N$ is the \emph{initial marking}.  For $x \in P \cup T$, we denote by
$\pre x$ the \emph{preset} of $x$, defined as $\{y \in P \cup T \mid (y, x) \in
F\}$.  Similarly, the \emph{postset} of $x$, written $\post x$, is defined by
$\{y \in P \cup T \mid (x, y) \in F\}$.  Finally, for a transition $t \in T$ we
write $\cont t$ to denote the \emph{context} of $t$, defined as $\{p \in P \mid
(p, t) \in C\}$.  The same notation is used to denote the context of a place $p
\in P$, that is, the set $\{t \in T \mid (p, t) \in C\}$.

Note that contextual nets are an extension of traditional Petri Nets.
Precisely, Petri Nets are the class of contextual nets whose context relation
is empty.

A \emph{marking} $m$ is a function $m : P \to \N$ that maps every place of $P$
to a natural number, including 0. If for a marking $m$ and place $p$, $m(p) =
n$, then we say that $m$ marks $p$ with $n$ tokens.  If a marking $m$ has the
set $\{0, \ldots, n\}$ for image, we say that $m$ is $n$-safe.  We will
associate, without further comment, every 1-safe marking to to a subset of $P$.

A transition $t \in T$ is said to be \emph{enabled} at a marking $m$ if $m$
marks every place of the preset and context of $t$ with at least one token,
i.e.,  if we have $m(p) > 0$ for $p \in \pre t \cup \cont t$.  Any transition
enabled at a marking can \emph{fire} (\emph{occur} or \emph{be executed}),
leading to a new marking.  Specifically, if $t$ is enabled at $m$, the
execution of $t$ at $m$ produces the new marking $$m'(p) = 
\begin{cases}
m(p) - 1 & \mbox{if } p \in \pre t \setminus \post t \\
m(p) + 1 & \mbox{if } p \in \post t \setminus \pre t \\
m(p) & \mbox{otherwise}
\end{cases}$$

A sequence of transitions that can fire one after the other starting at the
initial marking $m_0$ is called a \emph{run}.  Formally, a finite sequence of
transitions $\sigma = t_1 \ldots t_n \in T^*$ is a run if there exist markings
$m_1, \ldots, m_n$ such that $t_1$ is enabled at the initial marking $m_0$ and
produces $m_1$ when fired at $m_0$, and for $2 \le i \le n$, transition $t_i$
is enabled at $m_{i-1}$ and produces $m_i$ when fired at $m_{i-1}$.  Marking
$m_n$ is said to be the marking reached by $\sigma$.  Conversely, a marking is
said \emph{reachable} if there exists some run in the contextual net that
reaches it.  \FIXME{definir Runs(N) ?? Markings(N)??}

By extension, a contextual net $N$ is said to be $n$-safe if every reachable
marking of $N$ is $n$-safe; it is said \emph{safe} if it is $n$-safe for some
natural $n \in \N$.

\begin{figure}
\centering{\includegraphics{fig/a-1safe.fig}}
\caption{A 1-safe contextual net (a), a prefix of its full unfolding (b), the
folding morphism (c).}
\label{fig:a.1safe}
\end{figure}

\rfig{a.1safe} (a) depicts a contextual net that is 1-safe.  Read arcs are
represented by means of undirected lines.  For $t_2$, we have that $\{p_1\} =
\pre{t_2}$, $\{p_3\} = \cont{t_2}$ and $\{p_4\} = \post{t_2}$.  The initial
marking is $\{p_1, p_2\}$ and $t_1, t_2, t_3$ is a run that reaches marking
$\{p_2, p_4\}$.  Marking $\{p_3, p_4\}$ is reachable because it is the marking
reached by the run $t_1, t_2$.

\FIXME{General assumptions: (0) Input nets are always finite, $P$, $T$, $F$ and
$C$ are finite. (1) we restrict our interest to 1-safe nets, because they are
the more interesting. (2) We assume that no transition has an empty preset in N
(3) restriction about context and preset on transitions, search for it in the
notebook...}

\subsection{Unfolding contextual nets}

\FIXME{Decir que $\unf N$ is 1-safe!!}

\FIXME{Let us start with some intuitive ideas.}  Consider a directed graph $G$
and one node $v$ from $G$.  It is well known that one can unfold $G$ into a
labelled tree $U$ whose paths from the root node are in one to one
correspondence to the paths in $G$ starting from $v$.  A labelling $f$,
associating each node of $U$ to a node of $G$, implicitly provides this
correspondence.  Due to the tree-like structure of $U$, there is a natural well
founded precedence order on its nodes ($a$ precedes $b$ if so does in some path
from the root).

Construction of the tree is made recursively.  We start by appending to $U$ a
new node $u$ and updating $f$ with a new binding $f(u) = v$.  Then we regard
all nodes $v_1, \ldots, v_n$ in $G$ pointed by outgoing edges from $v$ and
append to $U$ new nodes $u_1, \ldots, u_n$, as well as the corresponding edges
from $u$.  The mapping $f$ is also updated with new bindings $f(u_1) = v_1,
\ldots, f(u_n) = v_n$.  This construction is next applied recursively to every
new node appended to $U$ in the previous step.  For this reason, the unfolding
operation naturally stops when no new node can be unfolded.  The resulting tree
$U$ is called the \emph{full} unfolding of $G$, and it is usually infinite.
The algorithm can also be stopped at an arbitrary point, yielding a finite
\emph{prefix} of the full unfolding.  \rfig{a.directed} illustrates a directed
graph (a) and a prefix of its full unfolding (b).

%\Ralg{directed.graph} describes with more detail this procedure.  Notice that
%the mapping $f$ is implicitly encoded the node set of $U$.  \Rfig{} illustrates
%its operation with a small graph its
%
%\begin{algorithm}
%\caption{Directed graph unfolding procedure}
%\label{alg:directed.graph}
%
%\begin{algorithmic}
%\REQUIRE $G = (V, E)$ and a node $v \in V$
%\ENSURE $U = (V', E')$, where $V' \subseteq V \times \N$
%
%\STATE $n = 1$ 
%\STATE $W = \emptyset$
%\STATE Add $\langle v, 0 \rangle$ to $W$
%\WHILE {$W \not= \emptyset$}
%\STATE Remove some $s = \langle u, n' \rangle$ from $W$
%\STATE Add $s$ to $V'$
%\FORALL {$(u, w) \in E$}
%\STATE Create new node $t = \langle w, n \rangle$
%\STATE $n := n + 1$
%\STATE Add $(s, t)$ to $E'$
%\STATE Add $t$ to $W$
%\ENDFOR
%\ENDWHILE
%\end{algorithmic}
%\end{algorithm}

\begin{figure}
\centering{\includegraphics{fig/a-directed.fig}}
\caption{A directed graph (a) together with an arbitrary prefix of its full
unfolding (b).}
\label{fig:a.directed}
\end{figure}

Following the same idea, a contextual net $N$ can also be unfolded into a
labelled \emph{contextual occurrence net} $\unf N$, that is, another contextual
net whose runs are in in one to one correspondence to the runs of the original
net.  A labelling, or folding morphism, consist on a pair of functions $\langle
f_T, f_P \rangle$ that associates each transition in $\unf N$ to a transition
in $N$ (through $f_T$) and each place of $\unf N$ to a place in $N$ (through
$f_P$).  Again, due to the acyclic and rooted structure of the contextual
occurrence net, there is a natural precedence (or causal) order on its
transitions and places.

Provided $N$, construction of $\unf N$ (as well as the folding morphisms $f_T$
and $f_P$) proceeds incrementally, adding a new transition together with the
places in its postset at each step.  We start by appending to $\unf N$ a copy
of the initial marking of $N$, and updating $f_P$ to reflect this copy.  Then,
we consider any reachable marking $m'$ of $\unf N$ and compute its image $m$
though $f_P$ (that is, $m$ is a marking in $N$).  If any transition $t$ from
$N$ is enabled at $m$ and no copy of $t$ firing from\footnote{To be precise, we
should say 'firing from the places in $\unf N$ whose image through $f_P$
conforms exactly the set $\pre t$' in $N$, instead of 'firing from $m'$'.} $m'$
is still present in $\unf N$, then a new copy of $t$ can be appended, as well
as new copies of places in $\post t$.  The folding morphisms are subsequently
updated to reflect the new transition and places in $\unf N$.  Mapping $f_T$ is
updated with a binding from the copy of $t$ to $t$, while mapping $f_P$ is
updated to reflect the copy of the postset of $t$.  The same procedure is
repeated until no new transition can be appended.  The resulting contextual net
$\unf N$ is called the \emph{full unfolding}, and it is usually infinite.
Nevertheless, the procedure can be stopped at any point, yielding a finite
\emph{prefix} of the full unfolding.

The full unfolding $\unf N$, or any prefix of it, is a contextual occurrence
net.  Runs of $\unf N$ corresponds to runs of $N$.  \FIXME{We will examine
later on some other relevant properties of contextual occurrence nets.}
Transitions of any contextual occurrence net will, from now, be called
\emph{events}, while its places will be called \emph{conditions}.
\rfig{a.1safe} illustrates a contextual net (a) together with an arbitrary
prefix of its full unfolding (b).  The folding morphism (c) is also given on
the right side of the figure.

The full unfolding $\unf N$ is infinite even for trivial examples (see
\rfig{a.1safe} (b)).  For this reason, we are interested in a prefix of $\unf
N$ large enough to be \emph{complete}, for some meaning of completeness.  In
particular, we are interested in computing a prefix whose reachable markings
are in one to one correspondence to the reachable markings of $N$.  In order to
define this prefix, we need to introduce some technical notions.  

\FIXME{For the reminder of this document}, we consider a 1-safe contextual net
$N = \langle P, T, F, C, m_0 \rangle$ and its full unfolding $\unf N = \langle
P', T', F', C', m'_0 \rangle$, together with the folding morphism $f_T : T' \to
T$ and $f_P : P' \to P$.  We let variable $t$ to range transitions in $T$,
variable $p$ for places in $P$, variable $e$ for events in $T'$ and variable
$c$ for conditions in $P'$.

\begin{definition}
\label{def:causality.relation}
The \emph{causality relation} in $\unf N$ is the least transitive relation $<$
on $P' \cup T'$ verifying

\begin{enumerate}
\item if $c \in \pre e$, then $c < e$;
\item if $c \in \post e$, then $e < c$;
\item if $\post e \cap \cont{e'}$, then $e < e'$.
\end{enumerate}
\end{definition}

Intuitively, the causality relation captures the notion of \textit{what must
occur first in \emph{any} run of $\unf N$ that fires or marks some transition
or place}.  For instance, regarding \rfig{a.1safe} (b), we have $c_3 < e_3$
since \emph{any} run firing $e_3$ will first mark $c_3$ (notice that all the
runs that fire $e_3$ are $e_1, e_3$ and $e_1, e_2, e_3$).  We also have $c_2 <
e_1$ and also $e_1 < e_2$.

For any condition or event $x \in P' \cup T'$, we denote by $[x]$ the set of
\emph{causes} of $x$, that is, the set $\{e \in T' \mid e \le x\}$, where $\le$
is the reflexive closure of $<$.  For instance, $[c_4] = \{e_1, e_2\}$ and
$[e_3] = \{e_1, e_3\}$.

Consider now events $e_2$ and $e_3$.  We cannot say that \emph{any} run that
fires $e_3$ first fires $e_2$ (as $e_1, e_3$ is a run).  However, we can assure
that \emph{if some run fires $e_2$ and $e_3$, then it will fire $e_2$ before
$e_3$} (since once fired $e_3$, condition $c_3$ cannot be read).  This
situation arises due to the existence of read arcs and is \FIXME{the cause to
the existence of several causal histories for some events}.  We characterize
this relation in the next definition

\begin{definition}
\label{def:asymmetric.conflict}
We say that two events $e, e' \in T'$ are in \emph{asymmetric conflict}, and
write $e \nearrow e'$, iff either (1) $e < e'$, or (2) $\cont e \cap \pre{e'}
\not= \emptyset$, or (3) $e \not= e' \land \pre e \cap \pre{e'} \not=
\emptyset$.
\end{definition}

Let us see why the intuition in the previous paragraph holds in the three
sub-cases.  If $e < e'$, clearly any run that fires both events also fires
first $e$.  If $\cont e \cap \pre{e'} \not = \emptyset$ (the case of $e_2$ and
$e_3$ in \rfig{a.1safe} (b)), then if both $e$ and $e'$ are present in the same
run, $e$ must read its context before $e'$ consumes at least one place of it.
Finally, observe that if $e \not = e'$ and $\pre e \cap \pre{e'} \not =
\emptyset$, then $e$ and $e'$ cannot be present in the same run, and the
intuition vacuously holds.  This allows us to capture symmetric
conflicts\footnote{In a 1-safe Petri Net (without read arcs), two transitions
are said to be in \emph{symmetric conflict} if they are different and share
some place in its respective presets.} by means of a loop of length two in the
asymmetric conflict relation.

For any set of events $X \subseteq T'$, we write $\nearrow_X$ to mean the
restriction of $\nearrow$ to $X$, that is, the relation $\nearrow \cap \ X
\times X$.  The next important notion is that one of configuration:

\begin{definition}
A finite set of events $C \subseteq T'$ is a \emph{configuration} of $\unf N$
iff (1) $\nearrow_C$ is acyclic and (2) $C$ is causally closed, that is, for
all $e' < e$ with $e \in C$, we have $e' \in C$.
\end{definition}

Configurations characterizes (concurrent) runs of $\unf N$.  A set of events is
a configuration iff all its events can be ordered to form a run.  Furthermore,
any ordering of the events of a configuration that conforms a run is compatible
with the asymmetric conflict relation $\nearrow$, hence the requirement that
$\nearrow_C$ is acyclic in the previous definition.  In \rfig{a.1safe} (b), the
set $\{e_1, e_2, e_3\}$ is a configuration, while the set $\{e_2\}$ is not,
since it is not causally closed.  We let $\conf{\unf N}$ denote the set of all
configurations of $\unf N$.

\FIXME{Present here $\evolves$ and $\confl$}

As any configuration $C$ is a run of $\unf N$, we can naturally associate to
$C$ the marking reached by that run.  We call that marking the \emph{cut} of
$C$.  In turn, any marking in $\unf N$ corresponds, via $f_P$, to a marking in
$N$.  We call this marking \emph{the marking} of $C$. For instance, the
marking of configuration $\{e_1, e_2\}$ in \rfig{a.1safe} (b) is $\{p_3,
p_4\}$, while its cut is $\{c_3, c_4\}$.

\begin{definition}
Let $C \in \conf{\unf N}$ be a configuration of the full unfolding.  We define
the \emph{cut} of $C$, written $\cut C$, and the \emph{marking} of $C$, written
$\marking C$ as $$\cut C \: = \: m \: \cup \: \bigcup_{e \in C} \post e \:
\setminus \: \bigcup_{e \in C} \pre e \qquad \mbox{ as well as } \qquad
\marking C \: = \: \bigcup_{c \in \cut C} f_P (c)$$
\end{definition}

Some configurations are called \emph{histories}.  Intuitively, given a
configuration $C$ and some event $e \in C$, the history of $e$ in $C$ is the
subset of $C$ that contains all events $e'$ that must fire before $e$ in $C$,
i.e., for which $e' (\nearrow_C)^* e$ holds.

\begin{definition}
Let $C \in \conf{\unf N}$ be a configuration of the $\unf N$ and $e \in C$ some
event of $C$.  The \emph{history} of $e$ in $C$, written $C \sem e$, is the set
$\{e' \in C \mid e' (\nearrow_C)^* e\}$.  Additionally, the set of all
histories for any event $e \in T'$, written $\hist e$, is defined to be the set
$\{C \sem e \mid C \in \conf{\unf N} \land e \in C\}$.
\end{definition}

We use the notation $H_e$ to denote any history $H_e \in \hist e$ of $e$.
Similarly, we set the notation $\event H$ to denote the event $e$ if $H \in
\hist e$.  Every history $H_e$ is a configuration.  To see this, let $C$ be a
configuration and $e \in C$ some event such that $H_e = C \sem e$.  As $H_e
\subseteq C$, it is clear that $\nearrow_{H_e}$ is acyclic.  To show that $H_e$
is causally closed, assume that $e' \in H_e$ is some event of $H_e$ and that
$e'' < e'$.  Then we have $e'' \nearrow e' (\nearrow_C)^* e$.  As $e'' \in C$,
we have $e'' (\nearrow_C)^* e$ and therefore $e'' \in H_e$.

In the unfolding of a Petri Net (without read arcs), any event $e$ can only
have one history (the so called \emph{local configuration} $[e]$, see
\FIXME{ref}).  The presence of read arcs gives rise to the existence of
multiple histories, or runs, per event, possibly infinite.  In \rfig{a.1safe}
(b), event $e_3$ have two histories, namely, $\{e_1, e_3\}$ (which coincides
with $[e_3]$) and $\{e_1, e_2, e_3\}$.


\subsection{FIXME Search for a title!!}

\FIXME{Remark that all? the notions presented till here are applicable to
$\pref N$}

Due to the fact that $\unf N$ is frequently infinite, we would like to define,
and then construct, a finite \emph{prefix} of $\unf N$ that is still
\emph{useful}.  A finite prefix of $\unf N$ is any 1-safe contextual net $\pref
N$ that results from stopping the unfolding algorithm of \FIXME{section x} at
an arbitrary point.  Useful, or \emph{complete}, will mean in this work that
the prefix is large enough to represent exactly the same reachable markings as
$N$, that is, such that $$\markings N = \bigcup_{C \in \conf{\pref N}}
\marking{C}$$ Other definitions are possible, for instance, we could require in
addition that all runs of $N$ are present in $\pref N$ \FIXME{ref}.  Under our
definition, it is clear that $\unf N$ is complete by construction.

\begin{proposition}
$\unf N$ is complete.
\end{proposition}

In order to construct a finite and complete prefix for Petri Net (without read
arcs) unfoldings, McMillan suggested \FIXME{ref} to define certain events of
$\unf N$ as \emph{cutoff} events, and let the unfolding algorithm to stop
either when no new event can be added or when any new event is a cutoff.  Then
he proved that, for a proper definition of cutoff events, his prefix was finite
and complete.  Roughly, cutoff events were defined to be those whose
corresponding run (history, causal closure or \emph{local configuration})
produces a marking that is reachable by a shorter run (firing less events).
His definition of cutoff relies on the fact each event has \emph{only one}
history and cannot be adapted without changes to the framework of contextual
nets.

The natural generalization of this idea is to consider that cutoffs are, not
events, but \emph{enriched events}, that is, pairs $\langle e, H_e \rangle$
where $e$ is an event and $H_e \in \hist e$.  The unfolding algorithm has also
to be modified to compute, not a prefix of $\unf N$, but an \emph{enriched
prefix}, that is, a pair $\langle \pref N, \chi \rangle$ such that $\pref N$ is
a prefix of $\unf N$ and $\chi : T' \to 2^{\conf{\unf N}}$ associates to all
events $e$ of $\pref N$ a non empty set of histories of $e$ (that is,
$\emptyset \not = \chi(e) \subseteq \hist{e}$), additionally
verifying\footnote{We impose this constrain on $\chi$ to conform the definition
of \emph{closed occurrence net} of \FIXME{baldan}.  Intuitively, this
constraint forces the enriched prefix to be such that the history of any event
$e$ present in the prefix is the union of the histories associated events $e'$
in asymmetric conflict to $e$.  Due to space constrains, we skip providing a
detailed motivation of this additional constraint and point the reader to
review Definition 12 of \FIXME{baldan}.} $H \in \chi (e)$ and $e' \in H$
implies $H \sem{e'} \in \chi (e')$.

Let us set some additional definitions. First, given an enriched prefix $\enr N
= \langle \pref N, \chi \rangle$, we set that a configuration $C$ of $\enr N$
is any configuration $C \in \conf{\pref N}$ that verifies $C \sem e \in \chi
(e)$ for all $e \in C$.  The set of configurations of $\enr N$ is denoted by
$\conf{\enr N}$.  Second, we consider by extension that $\unf N$ \emph{is} the
enriched prefix $\langle \unf N, \chi \rangle$ such that $\chi (e) = \hist{e}$
for $e \in T'$.  Finally, we say that $\langle e, H_e \rangle$ is an enriched
event \emph{of} a given enriched prefix $\langle \pref N, \chi \rangle$ if $e$
is an event of $\pref N$ and $H_e \in \chi (e)$.  We let variable $\varepsilon$
to range enriched events of any other enriched prefix.  Now we can define a
suitable generalization of cutoffs for contextual nets.

\begin{definition}
An enriched event $\langle e, H_e \rangle$ of $\unf N$ is called \emph{cutoff}
if either $\marking{H_e} = m_0$, the initial marking of $N$, or there exists
another enriched event $\langle e', H_{e'} \rangle$ of $\unf N$ verifying
$\marking{H_e} = \marking{H_{e'}}$ and $|H_e| < |H_{e'}|$.
\end{definition}

\rfig{a.complete} illustrates two enriched prefixes of the full unfolding of
\rfig{a.1safe} (a).  Histories associated to each event are depicted as sets
near the event.  The pair $\langle e_3, \{e_1, e_3\} \rangle$ is a enriched
event of (b), while it is not an enriched event of (a).  Regarding the enriched
prefix (b), imagine we remove history $\{e_1, e_2\}$ from $\chi (e_2)$.  The
resulting prefix would not conform the definition of enriched prefix, since,
setting $H = \{e_1, e_2, e_3\}$, we would have that $H \in \chi (e_3)$ and $e_2
\in H$ and not $H \sem{e_2} \in \chi (e_2)$, violating the condition stated on
$\chi$ in the definition of enriched prefix.  Finally, note that the enriched
prefix (b) is complete, while (a) is not.  Indeed, the marking $\{p_2, p_4\}$
is reachable in the original net, reachable in (b) through configuration
$\{e_1, e_2, e_3\}$ but unreachable in (a).  The two enriched events whose
event is $e'_1$ (depicted in gray in (b)) are cutoffs.  Precisely, enriched
event $\langle e'_1, \{e_1, e_3, e'_1\} \rangle$ is a cutoff because its
associated marking is the initial marking $\{p_1, p_2\}$.  Enriched event
$\langle e'_1, \{e_1, e_2, e_3, e'_1\} \rangle$ is a cutoff because its
associated marking $\{p_3, p_4\}$ is reachable by means of the smaller history
$\{e_1, e_2\}$.

\begin{figure}
\centering{\includegraphics{fig/a-complete.fig}}
\caption{A complete enriched prefix (b) of \rfig{a.1safe} (a), together with an
incomplete one (a).}
\label{fig:a.complete}
\end{figure}

The set of enriched prefixes of the full unfolding $\unf N$ is naturally
equipped with with an ordering.  Intuitively, enriched prefix $\enr N$ is a
\emph{prefix} of $\enr{N}'$ if the unfolding algorithm can append enriched
events to $\enr N$ to reach $\enr{N}'$.  Formally, enriched prefix $\enr N =
\langle \pref N, \chi \rangle$ is a prefix of $\enr{N}' = \langle \pref{N}',
\chi' \rangle$, written $\enr N \unlhd \enr{N}'$, iff $\pref N$ is a prefix of
$\pref{N}'$ and for all events $e$ in $\pref N$  we have $\chi (e) \subseteq
\chi' (e)$.

At this point, we can properly define the \emph{truncation} of the full
unfolding, that is, the greatest enriched prefix free of cutoffs, and state its
finiteness and completeness.

\begin{definition}
The \emph{truncation} of the full unfolding, denoted $\trunc N$, is the
greatest enriched prefix of $\unf N$, w.r.t. the $\unlhd$ ordering, which does
not contain any enriched event that is a cutoff.
\end{definition}

\begin{theorem}
$\trunc N$ has a finite number of enriched events and is complete.
\end{theorem}

\begin{proof} (Sketch, see theorems 1 and 2 of \FIXME{baldan}.)
By assumption, $N$ is finite and 1-safe net, and has finite reachable markings.
\FIXME{Observe} that the number of configurations of $\trunc N$ must be finite,
since if it were infinite, considering the fact that every configuration is
associated to one marking in $N$, we would have infinite cutoffs in $\trunc N$,
a contradiction.  As the number of configurations is finite, the number of
enriched events must be finite.

It is possible to prove that, for any configuration of $\unf N$ we can find a
configuration free of cutoffs\footnote{We say that a configuration $C$
\emph{contains} an enriched event $\langle e, H_e \rangle$ if $e \in C$ and
$H_e = C \sem e$.}.  That configuration must be present in $\trunc N$.  Since
$\unf N$ is complete, we can conclude that $\trunc N$ is also complete.
\end{proof}

\subsection{Challenging aspects of contextual vs Petri net unfoldings}

The main goal of this work is to provide an implementation of the unfolding
algorithm for contextual nets, as presented in \FIXME{baldan}.  The Mole
unfolder \FIXME{ref} served as inspiration for the implementation of the
contextual unfolder, but almost\footnote{Only the routines to read the
description of the contextual net from a file could be reused, as the
contextual unfolder uses almost the same input format than Mole.} no code could
be reused from Mole.  In this section, we justify why our implementation is not
just an extension of Mole, but a new 4700LOC\footnote{\textit{Lines Of Code}.}
tool written from scratch, by presenting the challenging aspects that arises
when unfolding contextual nets instead of Petri Nets.

\begin{figure}
\centering{\includegraphics{fig/read-arcs.fig}}
\caption{Read arcs can lead to loops of arbitrary length in the $\nearrow$
relation.}
\label{fig:read.arcs}
\end{figure}

\paragraph{Conflict relation on events.}  A set of events are in
\emph{conflict} iff no configuration (or run) fires all them together.  Hence,
determining if a set is a configuration amounts to check that there is no
subset of events in conflict.  In Petri Net unfoldings, this reduces to a
number of pairwise checks of events, relying on the fact that the (symmetric)
conflict relation is \emph{binary}.  In contextual net unfoldings, this is no
longer the case, as we have to check for a loop of \emph{any length} in the
(asymmetric) conflict relation.  \rfig{read.arcs} depicts a contextual net that
is equal to its own unfolding, in which we have the loop $e_1 \nearrow e_2
\nearrow e_3 \nearrow e_1$.  Events $e_1, e_2$ and $e_3$ are hence in conflict,
while any set of two events is free of conflict (and conforms a configuration).
Checking whether a set of events is a configuration is a central task of the
unfolding algorithm (see \FIXME{PE algorithm}) and can no longer be made by
checking for binary conflicts, as it is done in Mole.

\paragraph{Management of histories.}  While in the unfolding of a Petri Net,
each event conceptually represents only one run (or history) of the original
net, in the unfolding of a contextual net, events correspond to sets of
different runs in the original net.  As the unfolding algorithm used in this
work explicitly keeps track of the set of histories associated to each event,
we need to implement data structures an algorithms to deal with certain
operations performed on histories (for instance duplicate test, or conflict
test).  There is no explicit notion (data structure or algorithm) of history in
Mole that we could reuse or extend.

\paragraph{Concurrency relation on conditions.}  In the unfolding of a Petri
Net, each pair of conditions is either in \emph{causal} or \emph{concurrent} or
\emph{conflict} relation \FIXME{ref ERV, pag} but never in two relations at the
same time.  In a contextual net unfolding, two conditions can be in
(asymmetric) conflict and still be marked by some marking (be concurrent).
Conceptually, this \FIXME{imposibilita} the definition of a concurrency
relation between conditions.  Existence of such relation is successfully
exploited in Mole to speed up the computation.  For contextual unfoldings, we
can still define a concurrency relation on \emph{enriched conditions} (see
\FIXME{section}), but, again, we have to \FIXME{renunciar} to make an extension
of Mole and rather implement from scratch such relation.

\paragraph{Computational order $\evolves$ and asymmetric conflicts.} Given two
configurations $C_1, C_2$ we say that $C_1$ \emph{evolves to} $C_2$, and write
$C_1 \evolves C_2$, iff $C_1 \subseteq C_2$ and $\lnot (e_2 \nearrow e_1)$ for
all $e_1 \in C_1$ and $e_2 \in C_2 \setminus C_1$.  Intuitively, $C_1$ evolves
to $C_2$ if events in $C_2 \setminus C_1$ can be appended to the end of any
run of $C_1$ to build a run of $C_2$.  The contextual unfolder needs to compute
the relation $\evolves$ between histories each time it extends the unfolding by
one enriched event.  This requires to explicitly store (a simplified version
of) the asymmetric conflict relation between events (see \FIXME{section}).  No
need to store the symmetric conflict relation is present in Mole.

\section{Computing the unfolding}

In the previous section, we defined a finite and complete enriched prefix of
the full unfolding $\unf N$ of a 1-safe contextual net $N$.  In this section,
we provide an algorithm to compute a possibly larger enriched prefix $\enr N$
that is still finite and complete.

\FIXME{ref baldan} provides an abstract algorithm to compute such prefix.  In
the sequel, we detail the data structures and algorithms used to transform this
abstract algorithm into a concrete one that can be directly implemented.  Let
us first introduce the data structure used to store the output enriched prefix.
The unfolding procedure in \ralg{unfolding.procedure} outputs an enriched
prefix $\enr N = \langle \pref N, \chi \rangle$, with $\pref N = \langle P',
T', F', C', m'_0 \rangle$ and $\chi : T' \to 2^{2^{T'}}$, by encoding the flow
and context relations $F'$ and $C'$ in the data structures used for $P'$ and
$T'$.  Each event $e$ is represented by means of a tuple $\langle M_p, M_c, t
\rangle$, with $M_p, M_c \subseteq P'$ and $t \in T$.  Set $M_p$ is the preset
of $e$, set $M_c$ is the context of $e$ and $t$ is the transition of $N$ to
which $e$ corresponds.  Each condition $c$ is stored by means of a tuple
$\langle e, p \rangle$, with $e \in T'$ being an event of $\pref N$ and $p \in
P$ the place of $N$ to which $c$ corresponds.  Note that the folding morphisms
$f_P$ and $f_T$ are also encoded in this data structure, \FIXME{and will be
assumed to be defined for the current prefix as the algorithm advances.}
Finally, notice that in order to simplify the algorithm, we make use of a
special event $\bot$ that \textit{produces} the initial marking $m'_0$.  Event
$\bot$ is not mapped through $f_T$ to $N$ and can be safely removed from $\enr
N$ after the computation of the algorithm.

\FIXME{Remark that any global cutoff is a local cutoff due to the order we use
to extract events from $E$.} After reading \ralg{unfolding.procedure}, one sees
that two procedures remain undefined, namely \peupdate{} and \iscutoff{}.  We
define \peupdate{} in \rsec{computation.possible}, and \iscutoff{} here.
Procedure $\iscutoff (e, H)$ takes an enriched event as argument and returns
true if $\langle e, H \rangle$ is a cutoff, false otherwise.  Precisely,
$\iscutoff (e, H)$ returns true if it can find an event $e' \in T'$ and $H' \in
\chi (e')$ such that $\marking{H'} = \marking{H}$ and $|H'| < |H|$, false
otherwise.  It can be implemented by means of an exhaustive
search\footnote{Although we didn't implement it like that.  A more elaborated
version of it can be as follows:  we store a hash table mapping $\marking{H_e}$
to $\varepsilon = \langle e, H_e \rangle$ for every $\varepsilon$ of $\enr N$.
\FIXME{continue}.} of such $H'$ in the image of $\chi$.

\begin{algorithm}[b]
\caption{Unfolding procedure, see the text.}
\label{alg:unfolding.procedure}

\begin{algorithmic}
\REQUIRE A 1-safe contextual net $N = \langle P, T, F, C, m_0 \rangle$.
\ENSURE A finite and complete enriched prefix $\enr N = \langle \pref N, \chi
\rangle$ of the full unfolding of $N$, with $\pref N = \langle P', T', F', C',
m'_0 \rangle$ and $\chi : T' \to 2^{2^{T'}}$.

\vspace{1ex}
\STATE $T' = \{\bot\}$
\STATE $\chi (\bot) = \{\{\bot\}\}$
\STATE $m'_0 = \emptyset$
\STATE $m'_0 = m'_0 \cup \{\langle \bot, p \rangle\}$ for each $p \in m_0$
\STATE $P' = m'_0$

\STATE $E = \peupdate (\bot, \{\bot\})$
\WHILE {$E \not = \emptyset$}
\STATE Remove from $E$ some $\langle e, H \rangle$ minimal w.r.t $|H|$, and
assume that $e$ is $\langle M_p, M_c, t \rangle$
\IF{not $\iscutoff (e, H)$}
\STATE $T' = T' \cup \{e\}$
\STATE $\chi(e) = \chi(e) \cup \{H\}$
\STATE $P' = P' \cup \{\langle e, p \rangle\}$ for each $p \in \post t$
\STATE $E = E \cup \peupdate (e, H)$
\ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\subsection{Computation of the possible extensions}
\label{sec:computation.possible}

\ralg{unfolding.procedure} builds $\enr N = \langle \pref N, \chi \rangle$ by
starting from an empty enriched prefix and appending new enriched events to it,
one at each iteration of its only loop.  Each enriched event that is a
candidate to be appended to $\enr N$ at any point in the construction of $\enr
N$ is called a \emph{possible extension}.  Intuitively, possible extensions are
enriched events of $\unf N$, currently not present in $\enr N$, that are
\emph{enabled} at the cut of some configuration of $\enr N$.

%A set of events is called concurrent if all of them belong to the cut of some
%configuration.

\begin{definition}
\label{def:possible.extension}
Given an enriched prefix $\enr N = \langle \pref N, \chi \rangle$ of $\unf N$
and some enriched event $\varepsilon = \langle e, H_e \rangle$ of $\unf N$ that
is not an enriched event of $\enr N$, we call $\varepsilon$ a \emph{possible
extension} of $\enr N$ if $e = \langle M_p, M_c, t \rangle$ and $\pre t = f_P
(M_p)$ and $\cont t = f_P (M_c)$ and there is a configuration $C \in \conf{\enr
N}$ verifying $M_p \cup M_c \subseteq \cut C$ and $H_e = (C \cup \{e\}) \sem
e$.

Additionally, given an enriched event $\varepsilon' = \langle e', H_{e'}
\rangle$ of $\enr N$, a possible extension $\varepsilon = \langle e, H_e
\rangle$ of $\enr N$ is said to be \emph{induced by} $\varepsilon'$ if $e'
\nearrow e$ and $H_{e'} \subseteq H_e$.
\end{definition}

The set $E$ stores the possible extensions of $\enr N$.  Each new enriched
event $\varepsilon$ being appended to $\enr N$ appends at least one new
configuration to $\enr N$, possibly rendering $E$ out of date, as new enriched
events may now be possible extensions enabled at the cut of such configuration.
It is easy to see that any such possible extension is induced by $\varepsilon$.
Procedure \peupdate{} returns the set of possible extensions to $\enr N$
induced by the enriched event that takes as argument, and it is used to update
$E$ after the addition of any new enriched event.  Due to the space
constraints, we present here a declarative definition of \peupdate{}.  \FIXME{A
version in pseudocode is presented in APPENDIX.}

\begin{figure}[b]
\centering{\includegraphics{fig/discovery-possible.fig}}
\caption{(a) Possible extensions induced by $\langle e, H \rangle$. (b)
Computation of new histories for $e'$.}
\label{fig:discovery.possible}
\end{figure}

In order to compute the possible extensions induced by a given enriched event
$\langle e, H \rangle$, we consider enriched events $\langle e', H' \rangle$
with $e \nearrow e'$ (see \rfig{discovery.possible} (a)).  For such $e'$, we
compute a history $H'$ as the union of $\{e'\}$ and a family of histories
already present in $\enr N$.  That family, denoted by $\mathcal{F}_S$, will be
a set of histories whose union defines a configuration such that the cut
associated to that configuration marks the preset and context of $e'$.

More precisely, we enumerate all the tuples $e' = \langle M_p, M_c, t \rangle$
verifying that $f_P (M_p) = \pre t$, and $f_P (M_c) = \cont t$, and either
$\cont e \cap M_p \ne \emptyset$ or $\post e \cap (M_p \cup M_c) \ne
\emptyset$.  For each $e'$, we compute the sets of events $X = \pre{(M_p \cup
M_c)}$ and $Y = \cont{M_p}$ (see \rfig{discovery.possible} (b)).  Now, we
enumerate all subsets $S \subseteq Y$, and for each one we compute the set
$\mathcal{F}_S$, defined as the \emph{only} family of histories of events $X
\cup S \cup \{e\}$ that verifies $$ \{H\} \subseteq \mathcal{F}_S \subseteq
\bigcup_{e'' \in X \cup S \cup \{e\}} \chi (e'') \qquad \mbox{and} \qquad
|\mathcal{F}_S \cap \chi(e'')| = 1 \mbox{ for all } e'' \in X \cup S \cup
\{e\}$$  In other words, $\mathcal{F}_S$ is a set of histories containing
history $H$, one history for \emph{every} $e'' \in X$ and one history for
\emph{some} $e'' \in Y$.  Finally, for each $\mathcal{F}_S$, we generate the
enriched event $\langle e', H'_S \rangle$, with $$H'_S = \{e'\} \cup
\bigcup_{H'' \in \mathcal{F}_S} H'' \qquad \mbox{if} \qquad \lnot (H_1 \confl
H_2) \mbox{ for all } H_1, H_2 \in \mathcal{F}_S \quad \mbox{and} \quad
\conc{M_p \cup M_c}$$  The fist condition, $\lnot (H_1 \confl H_2)$ for all
$H_1, H_2$, assures that $H'_S \setminus \{e'\}$ is a configuration.  The
second condition, $\conc{M_p \cup M_c}$, verifies that $e'$ is enabled at
$\cut{H'_S \setminus \{e'\}}$, and can be easily computed by checking that no
history $H'' \in \mathcal{F}_S$ consumes\footnote{We can say that a
configuration (in particular, a history) \emph{consumes} a condition if any run
associated to the configuration so does.} any condition of $M_p \cup M_c$.

The abstract presentation of \FIXME{ref Baldan} subtly omitted to specify the
second condition.  Led by this specification, our first version of the
contextual unfolder was incorrect.  Only exhaustive testing discovered the bug
in the \peupdate{} algorithm and led to a modification of the conditions being
computed by that procedure, resulting in the addition of the test $\conc{M_p
\cup M_c}$.  

\FIXME{State that this is a contribution, and that the algorithm still
generates duplicates}

\subsection{Direct asymmetric conflict}

According to \rdef{asymmetric.conflict}, any two events $e, e'$ of an arbitrary
prefix $\pref N$ that are in causal relation, $e < e'$, are also in asymmetric
conflict relation, $e \nearrow e'$.  If we were interested in computing and
storing the $\nearrow$ relation this would become an issue, since $<$ is
transitive.  Furthermore, the $\nearrow$ relation is currently needed by our
contextual unfolder in order to compute the conflict relation $\confl$ between
histories.  We show in the sequel how we can \FIXME{define, store and use} a
simplified version of the asymmetric conflict relation that provides, for our
purposes, as much information as $\nearrow$.

\begin{definition}
\label{def:direct.asymmetric}
Given events $e$, $e'$ of $\unf N$, we say that $e$ is in \emph{direct
asymmetric conflict} to $e'$, and write $e \uparrow e'$, iff either
$\pre e \cap \pre{e'} \ne \emptyset$, or
$\cont e \cap \pre{e'} \ne \emptyset$, or
$\post e \cap \pre{e'} \ne \emptyset$ or
$\post e \cap \cont{e'} \ne \emptyset$
\end{definition}

\rfig{FIXME} illustrates \rdef{direct.asymmetric}.  For any depicted $e'$, we
have $e \uparrow e'$.  

For two given events $e$, $e'$, computation of $e
\uparrow e'$ only iterates through the preset and context of $e$ and $e'$,
while computing $e \nearrow e'$ can fall into the computation of $e < e'$.


 - uparrow es más pequeña que nearrow, esta contenida y es una restriccion
 - no guarda una relacion transitiva
 - Podemos probar el lemma:

$C_1 \evolves_{\!\!\!\uparrow} \; C_2$ iff $C_1 \subseteq C_2$ and $\lnot (e_2
\uparrow e_1)$ for all $e_1 \in C_1$ and $e_2 \in C_2 \setminus C_1$.

\begin{lemma}
For any pair of configurations $C_1, C_2 \in \conf{\unf N}$, we have $C_1
\evolves C_2$ iff $C_1 \evolves_{\!\!\!\uparrow} C_2$.
\end{lemma}

 - grafo $\agr N$, vertices, edges; el grafo puede actualizarse facilmente cada
   vez que se añade un evento al prefijo
 - figurita, ejemplo de un desenrollado


\subsection{History graph}

Presentación intuitiva y de alto nivel, nada de detalles. Piensa en el tiempo
que te queda.

 - Purpose: data structure to store the histories for each event
 - 

\subsection{Exploration order}


% - Baldan et al present the algorithm in an abstract way
% - Contents of the section
% - Brief explanation of data structures: events + conditions + encoding of fP,
%   fT, F', C'
% - Notation. Assume Pref N = P' T' F' C' m'0 is encoded by P', T' and m'0, as
%   well as functions fP and fT; bottom is a new event not associated to any
%   transition
% - Algorithm
% - \peupdate
%	- Lemma stating what peupdate does
%	- We need a way to avoid a systematic enumeration of all the
%	  configurations of the prefix
%	- Baldan proposes to define \#; two histories with no conflict
%	  form a configuration; then you can use that check for configurations
%	  using the histories of transitions generating Mp and Mc.  It is not
%	  said in the article that transitions in Mp and Mc have to be in
%	  the cut of the union of histories.
%	- Initial implementation of the unfolder was incorrect due to this
%	  subtlety.  Subsequent test discovered the bug and lead to a
%	  modification of the criterion to uncover new histories:
%	- We define enriched conditions and $\parallel$ on them as ...
%	- Present the algorithms; this is a contribution
%	- They still generate duplicate enriched events, we have to check for
%	  it
% - History graph
%	[ . check what happens with the duplicates ]
% 	. purpose
%	. presentation
%	. some lemma?
% - Adequate order
% 	. why it still works (wrt. the one proposed by Baldan), intuitions
%	. termination and completeness
% - Asymmetric conflict relation
% 	. relation used instead of the asymmetric conflict relation
%	. why it works (a lemma)
% - Optimizations
% 	. $\rho \parallel \rho'$; other lines of research (buscar esquema de
%	posibles lineas que me hizo una vez)




\section{Implementation issues}

 - Why from scratch
 - I/O formats
 - (Particular design of some component, if it's of interest)
 - Correction and testing
	. some of the algorithms implement definitions 'as is', without further
	optimizations
	. tests performed to validate the tool: isomorphism, reachability

\section{Conclusions and future work}

 - Summary
 - Still doesn't reach the performance of mole because we didn't have time?
 - Search for applications
 - Future work in phd
 	- More optimization
 - Search for applications

% Reservar para un apendice??
%The \emph{computational order} $\evolves$ between configurations captures the
%intuition that a configuration $C_1$ can evolve to a configuration $C_2$ if
%$C_1 \subseteq C_2$ an all events $C_2 \setminus C_1$ can be fired after
%$C_1$.  More formally, we define that $C_1 \evolves C_2$ holds iff $C_1
%\subseteq C_2$ and $\lnot (e_2 \nearrow e_1)$ for all $e_1 \in C_1$ and $e_2
%\in C_2 \setminus C_1$ holds.  Furthermore, two configurations are said to be
%in \emph{conflict}, written $C_1 \confl C_2$, when either $C_1 \not\evolves
%C_2$ or $C_2 \not\evolves C_1$.

%Still in \rfig{a.1safe} (b), we have that $\{e_1, e_2\} \evolves \{e_1, e_2,
%e_3\}$, while $\{e_1, e_3\} \not\evolves \{e_1, e_2, e_3\}$, since $e_2
%\nearrow e_3$.  Therefore $\{e_1, e_3\} \confl \{e_1, e_2, e_3\}$.

\end{document}

 % vim:syn=tex:spell:

